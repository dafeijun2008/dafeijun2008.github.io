(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{278:function(a,t,s){"use strict";s.r(t);var e=s(0),n=Object(e.a)({},function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack","aria-hidden":"true"}},[a._v("#")]),a._v(" Webpack")]),a._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#webpack"}},[a._v("Webpack")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-webpack-打包原理"}},[a._v("1.webpack 打包原理")])]),s("li",[s("a",{attrs:{href:"#_2-webpack-的优势"}},[a._v("2.webpack 的优势")])]),s("li",[s("a",{attrs:{href:"#概念问题一：什么是-webpack-和-grunt-和-gulp-有什么不同"}},[a._v("概念问题一：什么是 webpack 和 grunt 和 gulp 有什么不同")])]),s("li",[s("a",{attrs:{href:"#概念问题二：什么是-bundle-什么是-chunk，什么是-module"}},[a._v("概念问题二：什么是 bundle,什么是 chunk，什么是 module?")])]),s("li",[s("a",{attrs:{href:"#概念问题三：什么是-loader-什么是-plugin"}},[a._v("概念问题三：什么是 Loader?什么是 Plugin?")])]),s("li",[s("a",{attrs:{href:"#配置问题-如何可以自动生成-webpack-配置？"}},[a._v("配置问题:如何可以自动生成 webpack 配置？")])]),s("li",[s("a",{attrs:{href:"#开发问题一：webpack-dev-server-和-http-服务器如-nginx-有什么区别"}},[a._v("开发问题一：webpack-dev-server 和 http 服务器如 nginx 有什么区别?")])]),s("li",[s("a",{attrs:{href:"#开发问题二-什么-是模块热更新？"}},[a._v("开发问题二:什么 是模块热更新？")])]),s("li",[s("a",{attrs:{href:"#优化问题一：什么是长缓存？在-webpack-中如何做到长缓存优化？"}},[a._v("优化问题一：什么是长缓存？在 webpack 中如何做到长缓存优化？")])]),s("li",[s("a",{attrs:{href:"#优化问题二：什么是-tree-shaking-css-可以-tree-shaking-吗"}},[a._v("优化问题二：什么是 Tree-shaking?CSS 可以 Tree-shaking 吗")])]),s("li",[s("a",{attrs:{href:"#几个常见的-plugin-和常见的-loader"}},[a._v("几个常见的 plugin 和常见的 loader")])]),s("li",[s("a",{attrs:{href:"#webpack-构建过程"}},[a._v("webpack 构建过程")])]),s("li",[s("a",{attrs:{href:"#_6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全"}},[a._v("6.webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全")])]),s("li",[s("a",{attrs:{href:"#_7-是否写过-loader-和-plugin？描述一下编写-loader-或-plugin-的思路？"}},[a._v("7.是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？")])]),s("li",[s("a",{attrs:{href:"#_9-如何利用-webpack-来优化前端性能？（提高性能和体验）"}},[a._v("9.如何利用 webpack 来优化前端性能？（提高性能和体验）")])]),s("li",[s("a",{attrs:{href:"#_10-如何提高-webpack-的构建速度？"}},[a._v("10.如何提高 webpack 的构建速度？")])]),s("li",[s("a",{attrs:{href:"#_11-怎么配置单页应用？怎么配置多页应用？"}},[a._v("11.怎么配置单页应用？怎么配置多页应用？")])]),s("li",[s("a",{attrs:{href:"#_12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？"}},[a._v("12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？")])]),s("li",[s("a",{attrs:{href:"#_13-如何在-vue-项目中实现按需加载？"}},[a._v("13.如何在 vue 项目中实现按需加载？")])])])])])]),s("p"),a._v(" "),s("h3",{attrs:{id:"_1-webpack-打包原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack-打包原理","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.webpack 打包原理")]),a._v(" "),s("p",[a._v("把所有依赖打包成一个 bundle.js 文件，通过代码分割成单元片段并按需加载。")]),a._v(" "),s("h3",{attrs:{id:"_2-webpack-的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack-的优势","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.webpack 的优势")]),a._v(" "),s("p",[a._v("（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。")]),a._v(" "),s("p",[a._v("（2）能被模块化的不仅仅是 JS 了。")]),a._v(" "),s("p",[a._v("（3） 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转 base64 等。")]),a._v(" "),s("p",[a._v("（4）扩展性强，插件机制完善")]),a._v(" "),s("p",[a._v("webpack 的缺点")]),a._v(" "),s("p",[a._v("webpack 的缺点是只能用于采用模块化开发的项目")]),a._v(" "),s("h3",{attrs:{id:"概念问题一：什么是-webpack-和-grunt-和-gulp-有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念问题一：什么是-webpack-和-grunt-和-gulp-有什么不同","aria-hidden":"true"}},[a._v("#")]),a._v(" 概念问题一：什么是 webpack 和 grunt 和 gulp 有什么不同")]),a._v(" "),s("p",[a._v("答案：Webpack 是一个模块打包器，他可以递归的打包项目中的所有模块，最终生成几个打包后的文件。他和其他的工具最大的不同在于他支持 code-splitting、模块化(AMD，ESM，CommonJs)、全局分析。")]),a._v(" "),s("h3",{attrs:{id:"概念问题二：什么是-bundle-什么是-chunk，什么是-module"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念问题二：什么是-bundle-什么是-chunk，什么是-module","aria-hidden":"true"}},[a._v("#")]),a._v(" 概念问题二：什么是 bundle,什么是 chunk，什么是 module?")]),a._v(" "),s("p",[a._v("答案：bundle 是由 webpack 打包出来的文件，chunk 是指 webpack 在进行模块的依赖分析的时候，代码分割出来的代码块。module 是开发中的单个模块。")]),a._v(" "),s("h3",{attrs:{id:"概念问题三：什么是-loader-什么是-plugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念问题三：什么是-loader-什么是-plugin","aria-hidden":"true"}},[a._v("#")]),a._v(" 概念问题三：什么是 Loader?什么是 Plugin?")]),a._v(" "),s("p",[a._v("答案：\n1）Loaders 是用来告诉 webpack 如何转化处理某一类型的文件，并且引入到打包出的文件中\n2）Plugin 是用来自定义 webpack 打包过程的方式，一个插件是含有 apply 方法的一个对象，通过这个方法可以参与到整个 webpack 打包的各个流程(生命周期)。")]),a._v(" "),s("h3",{attrs:{id:"配置问题-如何可以自动生成-webpack-配置？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置问题-如何可以自动生成-webpack-配置？","aria-hidden":"true"}},[a._v("#")]),a._v(" 配置问题:如何可以自动生成 webpack 配置？")]),a._v(" "),s("p",[a._v("答案： webpack-cli /vue-cli /etc ...脚手架工具")]),a._v(" "),s("h3",{attrs:{id:"开发问题一：webpack-dev-server-和-http-服务器如-nginx-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发问题一：webpack-dev-server-和-http-服务器如-nginx-有什么区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 开发问题一：webpack-dev-server 和 http 服务器如 nginx 有什么区别?")]),a._v(" "),s("p",[a._v("答案：webpack-dev-server 使用内存来存储 webpack 开发环境下的打包文件，并且可以使用模块热更新，他比传统的 http 服务对开发更加简单高效。")]),a._v(" "),s("h3",{attrs:{id:"开发问题二-什么-是模块热更新？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发问题二-什么-是模块热更新？","aria-hidden":"true"}},[a._v("#")]),a._v(" 开发问题二:什么 是模块热更新？")]),a._v(" "),s("p",[a._v("答案:模块热更新是 webpack 的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//通过配置文件")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" webpack "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'webpack'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" path "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'path'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" env "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" process"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("NODE_ENV")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"development"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"development"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"production"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" config "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n          mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" env"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n         devServer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n             hot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),a._v("\n         "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n          plugins"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n             "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("webpack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("HotModuleReplacementPlugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//热加载插件")]),a._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n        module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n         "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"scripts"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"echo \\"Error: no test specified\\" && exit 1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"start"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"NODE_ENV=development  webpack-dev-server --config  webpack.develop.config.js --hot"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n")])])]),s("h3",{attrs:{id:"优化问题一：什么是长缓存？在-webpack-中如何做到长缓存优化？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化问题一：什么是长缓存？在-webpack-中如何做到长缓存优化？","aria-hidden":"true"}},[a._v("#")]),a._v(" 优化问题一：什么是长缓存？在 webpack 中如何做到长缓存优化？")]),a._v(" "),s("p",[a._v("答案：浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。在 webpack 中可以在 output 纵输出的文件指定 chunkhash,并且分离经常更新的代码和框架代码。通过 NameModulesPlugin 或是 HashedModuleIdsPlugin 使再次打包文件名不变。")]),a._v(" "),s("h3",{attrs:{id:"优化问题二：什么是-tree-shaking-css-可以-tree-shaking-吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化问题二：什么是-tree-shaking-css-可以-tree-shaking-吗","aria-hidden":"true"}},[a._v("#")]),a._v(" 优化问题二：什么是 Tree-shaking?CSS 可以 Tree-shaking 吗")]),a._v(" "),s("p",[a._v("答案：Tree-shaking 是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。在 webpack 中 Tree-shaking 是通过 uglifySPlugin 来 Tree-shaking\nJS。Css 需要使用 Purify-CSS。")]),a._v(" "),s("h3",{attrs:{id:"几个常见的-plugin-和常见的-loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几个常见的-plugin-和常见的-loader","aria-hidden":"true"}},[a._v("#")]),a._v(" 几个常见的 plugin 和常见的 loader")]),a._v(" "),s("p",[a._v("plugin:")]),a._v(" "),s("ul",[s("li",[a._v("html-webpack-plugin 为 html 文件中引入的外部资源，可以生成创建 html 入口文件")]),a._v(" "),s("li",[a._v("mini-css-extract-plugin 分离 css 文件")]),a._v(" "),s("li",[a._v("clean-webpack-plugin 删除打包文件")]),a._v(" "),s("li",[a._v("HotModuleReplacementPlugin 热更新应用")]),a._v(" "),s("li",[a._v("copy-webpack-plugin 拷贝静态文件")]),a._v(" "),s("li",[a._v("terser-webpack-plugin 通过 TerserPlugin 压缩 ES6 代码")])]),a._v(" "),s("p",[a._v("loader:")]),a._v(" "),s("ul",[s("li",[a._v("css-loader 加载 CSS，支持模块化、压缩、文件导入等特性")]),a._v(" "),s("li",[a._v("image-loader 加载并且压缩图片文件")]),a._v(" "),s("li",[a._v("babel-loader 把 ES6 转换成 ES5")]),a._v(" "),s("li",[a._v("style-loader 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS")]),a._v(" "),s("li",[a._v("file-loader 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件")]),a._v(" "),s("li",[a._v("source-map-loader 加载额外的 Source Map 文件，以方便断点调试")])]),a._v(" "),s("h3",{attrs:{id:"webpack-构建过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-构建过程","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 构建过程")]),a._v(" "),s("ul",[s("li",[a._v("从 entry 里配置的 module 开始递归解析 entry 依赖的所有 module")]),a._v(" "),s("li",[a._v("每找到一个 module，就会根据配置的 loader 去找对应的转换规则")]),a._v(" "),s("li",[a._v("对 module 进行转换后，再解析出当前 module 依赖的 module")]),a._v(" "),s("li",[a._v("这些模块会以 entry 为单位分组，一个 entry 和其所有依赖的 module 被分到一个组 Chunk")]),a._v(" "),s("li",[a._v("最后 webpack 会把所有 Chunk 转换成文件输出")]),a._v(" "),s("li",[a._v("在整个流程中 webpack 会在恰当的时机执行 plugin 里定义的逻辑")])]),a._v(" "),s("h3",{attrs:{id:"_6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全")]),a._v(" "),s("p",[a._v("Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),a._v(" "),s("ol",[s("li",[a._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；")]),a._v(" "),s("li",[a._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；")]),a._v(" "),s("li",[a._v("确定入口：根据配置中的 entry 找出所有的入口文件；")]),a._v(" "),s("li",[a._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")]),a._v(" "),s("li",[a._v("完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")]),a._v(" "),s("li",[a._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；")]),a._v(" "),s("li",[a._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")]),a._v(" "),s("li",[a._v("在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。")])]),a._v(" "),s("h3",{attrs:{id:"_7-是否写过-loader-和-plugin？描述一下编写-loader-或-plugin-的思路？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-是否写过-loader-和-plugin？描述一下编写-loader-或-plugin-的思路？","aria-hidden":"true"}},[a._v("#")]),a._v(" 7.是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？")]),a._v(" "),s("p",[a._v('Loader 像一个"翻译官"把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。')]),a._v(" "),s("p",[a._v('编写 Loader 时要遵循单一原则，每个 Loader 只做一种"转义"工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。')]),a._v(" "),s("p",[a._v("相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),a._v(" "),s("h3",{attrs:{id:"_9-如何利用-webpack-来优化前端性能？（提高性能和体验）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何利用-webpack-来优化前端性能？（提高性能和体验）","aria-hidden":"true"}},[a._v("#")]),a._v(" 9.如何利用 webpack 来优化前端性能？（提高性能和体验）")]),a._v(" "),s("p",[a._v("用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。")]),a._v(" "),s("ul",[s("li",[a._v("压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css")]),a._v(" "),s("li",[a._v("利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径")]),a._v(" "),s("li",[a._v("删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数--optimize-minimize 来实现\n提取公共代码。")])]),a._v(" "),s("h3",{attrs:{id:"_10-如何提高-webpack-的构建速度？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何提高-webpack-的构建速度？","aria-hidden":"true"}},[a._v("#")]),a._v(" 10.如何提高 webpack 的构建速度？")]),a._v(" "),s("ul",[s("li",[a._v("多入口情况下，使用 CommonsChunkPlugin 来提取公共代码")]),a._v(" "),s("li",[a._v("通过 externals 配置来提取常用库")]),a._v(" "),s("li",[a._v("利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。")]),a._v(" "),s("li",[a._v("使用 Happypack 实现多线程加速编译")]),a._v(" "),s("li",[a._v("使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度")]),a._v(" "),s("li",[a._v("使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码")])]),a._v(" "),s("h3",{attrs:{id:"_11-怎么配置单页应用？怎么配置多页应用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-怎么配置单页应用？怎么配置多页应用？","aria-hidden":"true"}},[a._v("#")]),a._v(" 11.怎么配置单页应用？怎么配置多页应用？")]),a._v(" "),s("p",[a._v("单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述")]),a._v(" "),s("p",[a._v("多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：")]),a._v(" "),s("p",[a._v("每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表\n随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置")]),a._v(" "),s("h3",{attrs:{id:"_12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？","aria-hidden":"true"}},[a._v("#")]),a._v(" 12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？")]),a._v(" "),s("p",[a._v("Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。")]),a._v(" "),s("p",[a._v("NPM 模块需要注意以下问题：")]),a._v(" "),s("ul",[s("li",[a._v("要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。")]),a._v(" "),s("li",[a._v("Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。")]),a._v(" "),s("li",[a._v("Npm 包大小应该是尽量小（有些仓库会限制包大小）")]),a._v(" "),s("li",[a._v("发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。")]),a._v(" "),s("li",[a._v("UI 组件类的模块应该将依赖的其它资源文件，例如.css 文件也需要包含在发布的模块里。")])]),a._v(" "),s("p",[a._v("基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化：")]),a._v(" "),s("ul",[s("li",[a._v("CommonJS 模块化规范的解决方案： 设置 output.libraryTarget='commonjs2'使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用")]),a._v(" "),s("li",[a._v("输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: 'source-map'输出 SourceMap 以发布调试。")]),a._v(" "),s("li",[a._v("Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc 文件，为其加入 transform-runtime 插件")]),a._v(" "),s("li",[a._v("不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。")]),a._v(" "),s("li",[a._v("对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下：")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" ExtractTextPlugin "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"extract-text-webpack-plugin"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\nmodule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    rules"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 增加对 CSS 文件的支持")]),a._v("\n        test"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[a._v("/\\.css/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 提取出 Chunk 中的 CSS 代码到单独的文件中")]),a._v("\n        use"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" ExtractTextPlugin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("extract")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n          use"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"css-loader"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  plugins"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ExtractTextPlugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 输出的 CSS 文件名称")]),a._v("\n      filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"index.css"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h3",{attrs:{id:"_13-如何在-vue-项目中实现按需加载？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-如何在-vue-项目中实现按需加载？","aria-hidden":"true"}},[a._v("#")]),a._v(" 13.如何在 vue 项目中实现按需加载？")]),a._v(" "),s("p",[a._v("Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。")]),a._v(" "),s("p",[a._v("不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在.babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"presets"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"es2015"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"modules"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"plugins"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"component"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"libraryName"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"element-ui"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"styleLibraryName"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"theme-chalk"')]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。")]),a._v(" "),s("p",[a._v("通过 import("),s("em",[a._v(")语句来控制加载时机，webpack 内置了对于 import(")]),a._v(")的解析，会将 import("),s("em",[a._v(")中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到 import(")]),a._v(")语句时，会去加载 Chunk 对应生成的文件。import()会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill")])])},[],!1,null,null,null);t.default=n.exports}}]);