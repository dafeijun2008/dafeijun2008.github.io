<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 | Dajun</title>
    <meta name="description" content="笔记">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.7f3e8fa0.css" as="style"><link rel="preload" href="/assets/js/app.3c18ba2b.js" as="script"><link rel="preload" href="/assets/js/2.2d7f6841.js" as="script"><link rel="preload" href="/assets/js/7.8c724b93.js" as="script"><link rel="prefetch" href="/assets/js/10.4e623ea8.js"><link rel="prefetch" href="/assets/js/11.1b2a7179.js"><link rel="prefetch" href="/assets/js/12.8062ade3.js"><link rel="prefetch" href="/assets/js/13.edc49012.js"><link rel="prefetch" href="/assets/js/14.e84ee3f4.js"><link rel="prefetch" href="/assets/js/15.e8d4142b.js"><link rel="prefetch" href="/assets/js/16.40a39847.js"><link rel="prefetch" href="/assets/js/17.1c075161.js"><link rel="prefetch" href="/assets/js/18.34b4e583.js"><link rel="prefetch" href="/assets/js/19.7f97ee03.js"><link rel="prefetch" href="/assets/js/20.aabac5c0.js"><link rel="prefetch" href="/assets/js/21.d261013f.js"><link rel="prefetch" href="/assets/js/22.b7560755.js"><link rel="prefetch" href="/assets/js/23.eb76ccea.js"><link rel="prefetch" href="/assets/js/24.6d592b30.js"><link rel="prefetch" href="/assets/js/25.b30f5339.js"><link rel="prefetch" href="/assets/js/26.8efe380d.js"><link rel="prefetch" href="/assets/js/27.94f1d5b7.js"><link rel="prefetch" href="/assets/js/28.4d86e4cc.js"><link rel="prefetch" href="/assets/js/29.2b342c8d.js"><link rel="prefetch" href="/assets/js/3.976ff7bf.js"><link rel="prefetch" href="/assets/js/30.68cd5081.js"><link rel="prefetch" href="/assets/js/31.fef0ba54.js"><link rel="prefetch" href="/assets/js/32.baa6441c.js"><link rel="prefetch" href="/assets/js/33.9c22ff1b.js"><link rel="prefetch" href="/assets/js/34.a08208a6.js"><link rel="prefetch" href="/assets/js/35.f0d94ae9.js"><link rel="prefetch" href="/assets/js/36.8f885fc3.js"><link rel="prefetch" href="/assets/js/37.7fd3e68c.js"><link rel="prefetch" href="/assets/js/38.bd73a7cf.js"><link rel="prefetch" href="/assets/js/39.2dca5b84.js"><link rel="prefetch" href="/assets/js/4.ab25bdf6.js"><link rel="prefetch" href="/assets/js/40.e324d414.js"><link rel="prefetch" href="/assets/js/41.32b91a1c.js"><link rel="prefetch" href="/assets/js/42.fee64b88.js"><link rel="prefetch" href="/assets/js/43.fc4fcb6c.js"><link rel="prefetch" href="/assets/js/44.3aeab9ce.js"><link rel="prefetch" href="/assets/js/45.811463a8.js"><link rel="prefetch" href="/assets/js/46.94aea5ef.js"><link rel="prefetch" href="/assets/js/47.2863ce6a.js"><link rel="prefetch" href="/assets/js/48.4239ef8f.js"><link rel="prefetch" href="/assets/js/49.7e48151d.js"><link rel="prefetch" href="/assets/js/5.c62fc94e.js"><link rel="prefetch" href="/assets/js/6.5bb0aa3d.js"><link rel="prefetch" href="/assets/js/8.d40cf774.js"><link rel="prefetch" href="/assets/js/9.a84cb03a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f3e8fa0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dajun</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link router-link-active">转载</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link router-link-active">转载</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>原理</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Reprint/%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/" class="sidebar-link">那些前端应该知道的HTTP知识</a></li><li><a href="/Reprint/原理基础/huancun.html" class="sidebar-link">浏览器HTTP缓存机制</a></li><li><a href="/Reprint/原理基础/xiancheng.html" class="active sidebar-link">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></li><li><a href="/Reprint/原理基础/web.html" class="sidebar-link">一篇文章理解 Web 缓存</a></li><li><a href="/Reprint/原理基础/v8.html" class="sidebar-link">V8 引擎</a></li><li><a href="/Reprint/原理基础/yinqing.html" class="sidebar-link">JS 引擎的执行机制</a></li><li><a href="/Reprint/原理基础/v8neicun.html" class="sidebar-link">V8 内存浅析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="从浏览器多进程到-js-单线程，js-运行机制最全面的一次梳理"><a href="#从浏览器多进程到-js-单线程，js-运行机制最全面的一次梳理" aria-hidden="true" class="header-anchor">#</a> 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</h2> <p>WQTech 2018-07-03</p> <p><strong>大纲</strong></p> <ul><li>（一）区分进程和线程</li> <li>（二）浏览器是多进程的</li></ul> <ol><li>浏览器都包含哪些进程？</li> <li>浏览器多进程的优势</li> <li>重点是浏览器内核（渲染进程）</li> <li>Browser 进程和浏览器内核（Renderer 进程）的通信过程</li></ol> <ul><li>（三）梳理浏览器内核中线程之间的关系</li></ul> <ol><li>GUI 渲染线程与 JS 引擎线程互斥</li> <li>JS 阻塞页面加载</li> <li>WebWorker，JS 的多线程？</li> <li>WebWorker 与 SharedWorker</li></ol> <ul><li>（四）简单梳理下浏览器渲染流程</li></ul> <ol><li>load 事件与 DOMContentLoaded 事件的先后</li> <li>css 加载是否会阻塞 dom 树渲染？</li> <li>普通图层和复合图层</li></ol> <ul><li>（五）从 Event Loop 谈 JS 的运行机制</li></ul> <ol><li>事件循环机制进一步补充</li> <li>单独说说定时器</li> <li>setTimeout 而不是 setInterval</li></ol> <ul><li><p>（六）事件循环进阶：macrotask 与 microtask</p> <div class="tip custom-block"><p>（一）、区分进程和线程</p></div> <p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p></li> <li><p>进程是一个工厂，工厂有它的独立资源</p></li> <li><p>工厂之间相互独立</p></li> <li><p>线程是工厂中的工人，多个工人协作完成任务</p></li> <li><p>工厂内有一个或多个工人 - 工人之间共享空间</p></li></ul> <p>再完善完善概念：</p> <ul><li>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</li> <li>工厂之间的相互独立 -&gt; 进程之间相互独立</li> <li>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</li> <li>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</li> <li>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</li></ul> <p>然后再巩固下：
如果是 windows 电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及 cpu 占有率。</p> <p><img src="/assets/img/x1.2c51f7cb.jpg" alt="img"></p> <p>所以，应该更容易理解了：**进程是 cpu 资源分配的最小单位（系统会给它分配内存） **<br>
最后，再用较为官方的术语描述一遍：</p> <ul><li>进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位</li> <li>线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
<strong>tips</strong></li> <li>不同进程之间也可以通信，不过代价较大</li> <li>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）<div class="tip custom-block"><p>（二）浏览器是多进程的</p></div>
理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</li> <li>浏览器是多进程的</li> <li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li> <li>简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。
关于以上几点的验证，请再第一张图：
<img src="/assets/img/x2.3e19529c.jpg" alt="img"></li></ul> <p>图中打开了 Chrome 浏览器的多个标签页，然后可以在 Chrome 的任务管理器中看到有多个进程（分别是每一个 Tab 页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个 Tab 页，进程正常会+1 以上</p> <blockquote><p>**注意：**在这里浏览器应该也有自己的优化机制，有时候打开多个 tab 页后，可以在 Chrome 任务管理器中看到，有些进程被合并了 （所以每一个 Tab 标签对应一个进程并不一定是绝对的）</p></blockquote> <p><strong>浏览器都包含哪些进程？</strong>
知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p> <ol><li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有</li></ol> <ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li> <li>负责各个页面的管理，创建和销毁其他进程</li> <li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li> <li>网络资源的管理，下载等</li></ul> <ol><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li> <li>GPU 进程：最多一个，用于 3D 绘制等</li> <li>浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为</li></ol> <ul><li>页面渲染，脚本执行，事件处理等<div class="warning custom-block"><p>强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）、</p></div>
当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</li></ul> <p><img src="/assets/img/x3.3fd4212b.jpg" alt="img"></p> <p>另外，可以通过 Chrome 的更多工具 -&gt; 任务管理器自行验证<br>
浏览器多进程的优势<br>
相比于单进程浏览器，多进程有如下优点：</p> <ul><li>避免单个 page crash 影响整个浏览器</li> <li>避免第三方插件 crash 影响整个浏览器</li> <li>多进程充分利用多核优势</li> <li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<div class="warning custom-block"><p>简单点理解：如果浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</p></div>
当然，内存等资源消耗也会更大，有点空间换时间的意思。<br>
重点是浏览器内核（渲染进程）<br>
重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是<strong>渲染进程</strong>
可以这样理解，页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程<div class="warning custom-block"><p>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）</p></div>
终于到了线程这个概念了 😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</li></ul> <ol><li>GUI 渲染线程</li></ol> <ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li> <li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
<blockquote><ul><li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li></ul></blockquote></li></ul> <ol start="2"><li>JS 引擎线程</li></ol> <ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li> <li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li> <li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
<blockquote><ul><li>同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul></blockquote></li></ul> <ol start="3"><li>事件触发线程</li></ol> <ul><li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li> <li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li> <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
<blockquote><ul><li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li></ul></blockquote></li></ul> <ol start="4"><li>定时触发器线程</li></ol> <ul><li>传说中的 setInterval 与 setTimeout 所在线程</li> <li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li> <li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
<blockquote><ul><li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li></ul></blockquote></li></ul> <ol start="5"><li>异步 http 请求线程</li></ol> <ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li> <li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。<br>
看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：</li></ul> <p><img src="/assets/img/x5.3c528cb5.jpg" alt="img"></p> <p>再说一点，为什么 JS 引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。<br> <strong>Browser 进程和浏览器内核（Renderer 进程）的通信过程</strong>
看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的 Browser 进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p> <p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开 Tab 页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多)</strong></p> <ol><li>Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程</li> <li>Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li></ol> <ul><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染</li> <li>当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）</li> <li>最后 Render 进程将结果传递给 Browser 进程</li></ul> <ol start="3"><li>rowser 进程接收到结果并将结果绘制出来
这里绘一张简单的图：（很简化）</li></ol> <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAFFAdgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiphaXBUMsEhBGQQho+x3P/PvL/3waAIaKm+x3P8Az7y/98Gj7Hc/8+8v/fBoAhoqb7Hc/wDPvL/3waPsdz/z7y/98GgCGipvsdz/AM+8v/fBo+x3P/PvL/3waAIaKm+x3P8Az7y/98Gj7Hc/8+8v/fBoAhoqb7Hc/wDPvL/3waPsdz/z7y/98GgCGipvsdz/AM+8v/fBo+x3P/PvL/3waAIaKm+x3P8Az7y/98Gj7Hc/8+8v/fBoAhoqVreWMZkjdATjLKRUVABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH0P8INF0zUfBrzXunWdzItyUDzW6uQPLQ4yR05PFd9/wAIr4e/6AWmf+Akf+Fcf8FP+RHl/wCvs/8AoqOvR6zlLU9CnGLiZP8AwjHh7/oA6Z/4CR/4Uf8ACMeH/wDoAaX/AOAkf+FatFLmNOWPYyv+EY8P/wDQA0v/AMBI/wDCj/hGPD//AEANL/8AASP/AArVoo5g5Y9jK/4Rjw//ANADS/8AwEj/AMKP+EY8P/8AQA0v/wABI/8ACtWijmDlj2Mr/hGPD/8A0ANL/wDASP8Awo/4Rjw//wBADS//AAEj/wAK1aKOYOWPYyv+EY8P/wDQA0v/AMBI/wDCj/hGPD//AEANL/8AASP/AArVoo5g5Y9jK/4Rjw//ANADS/8AwEj/AMKP+EY8P/8AQA0v/wABI/8ACtWijmDlj2Mr/hGPD/8A0ANL/wDASP8Awo/4Rjw//wBADTP/AAEj/wAK1aKOYOWPY+e/jbZ2ljrNmlnaQWyPbIzLDGEBO6TnA715RXrvx3/5Dlh/16J/6HJXkdXHY86orTaEooxRiqICijFGKACijFGKACijFGKACijFGKACijFGKACijFGKACijFGKACijFGKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPpb4K/wDIjyf9fZ/9FR16LXnXwV/5EeT/AK+z/wCio69FrGW56NL4UFFFFSaphRRRQMKKKKBBRRRQAUUySWKCJpZpEjjUZZ3OAB7mmvcwR3MNu80SzT7vKjZwGfaMnaOpwOTjpQBLRUEF5a3Not1b3MM0DdJY5AyHtw3Trmq7a7o6Y36rYrnpm5T6Hv65oE5JF+ioLS9tb+Iy2d1BcRg4LwyBwD6ZFWMUAeBfHj/kN2H/AF6J/wChy15BXsHx4/5Ddh/16J/6HLXj9bQ+E86r8bCiiiqMwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPpb4K/wDIjyf9fZ/9FR16LXnXwV/5EeT/AK+z/wCio69FrGW56NL4TyTXIdPm+IGvC/0a/wBTAhi8tbMMSjeVHydpGB+dXbLxLfaD8OtJu7S4t9RuGvvs7rLuJjBDHZyQQwwPz7jFdFeeEtRbxFfavpuv/YXu1RXT7GshAVVXglv9nPAqBvh9APD9rpcGoSK0V8L6WeSMOZXwQeMjHUflSJcZ3bQ7VPEmu6PY2Frc2lhJrGoXDRwxxM5hRRj7xPJIyOmBUUXijW421nTbyzsl1iwtftkTQhmhkQYJ4yGB59f5VteIfDqa7Haut1JaXlpJ5tvcRgEoeM8HqOBUWieF/wCzry81C+v5NR1G7jEUk7xqg2DHyhR06D8qBtTuYY8eztqHh6JIoWt72OH7ZJtP7t5CVAXnj5lbrnin3fjLU4fC95rC2NvKn9otbWx2ttSIZAkk6k8gjjFOtvhylto19YjUiZJ5I3gn8nmAI25Rjdz1Pcda14/Dt1ZeGbHSNL1Y2ctrjNwLcOJOG3ZQnGCWJ60AlMyrjxld6X4Rk1XUH0y7uJLjyLc2LsYWyM/MTyMfNkVU0X4hXN/BrEUqWEtzY2Ml3FNapIIn2joQ+G6kemeavw/DyzXw7daZPfTyT3Fz9rNyqhNkvOCqDgDk8e/bjGjDoGpvpGpWOpa69815bmBHa2VFiBVhnap+Y/N3Pagn3zC/tjXNW8EXWqalo1hd6bNbsTBDK0UmBne53ZGBjIAyeK5bUbvRk13w7nV9UsoI7T9+qzO7WQaBCgjbZ/FnBxn8K9AvdD1G08CDQdMeG4uDELYySgoNjEhmxk4wD7/j0rnrLTPEuk6rbXL+H11GSzsxZQyRahHHGVGMMFYZDYzn600TPm6nJWtzpzfDuaAXa3F7HmZ7S7MojgG50Bh2gDeTIpwSQe44qaFLayOm31y3hxA2moiwTWs0yFSx+dtiEeZkEHngg10tt4f1S48GT6HfaHJbrZQyzWrG8SVp5SH2rhRxgvnPqBVDUPCmuTaLBp9ho9zBGbWASbNQRIZZdqM7PCRy2crkn+EHtVaEyUm1odH8N3tvsuqJBcWkrvdG4ZLSCSOOMOOAodRx8p4GcV29cx4Pt9VsoLiDVLe8jGQ0cl3qAumY4wQMAbQMD866eoZ1Q2PA/jx/yG7D/r0T/wBDlrx+vYPjx/yG7D/r0T/0OWvH61j8J59X42FFFFUZhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAfS3wV/wCRHk/6+z/6Kjr0WvOvgr/yI8n/AF9n/wBFR16LWMtz0aXwhRRRSNQooooGFFFFBLCiiigAooooEFFFFAwooooA8E+PH/IbsP8Ar0T/ANDlrx+vYPjx/wAhuw/69E/9Dlrx+tY/CedV+NhRRRVGYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFOVC7BVBLE4AFAH0p8Ff+RHk/wCvs/8AoqOvRa8L8CeP7Hwb4fOmX1szzNL5pxIox8irjn3U103/AAuzRv8Anzk/7/pWUk29Dup1IqOp6dRXmP8AwuvRv+fOT/v+n+NJ/wALr0b/AJ85P+/6f40uVl+1h3PT6K8x/wCF16N/z5yf9/0/xo/4XXo3/PnJ/wB/0/xo5WP20O56dRXmP/C69G/585P+/wCn+NH/AAuvRv8Anzk/7/p/jRysXtodz06ivMf+F16N/wA+cn/f9P8AGj/hdejf8+cn/f8AT/GjlYe1h3PTqK8x/wCF16N/z5yf9/0/xo/4XXo3/PnJ/wB/0/xo5WHtYdz06ivMf+F16N/z5yf9/wBP8aP+F16N/wA+cn/f9P8AGjlYe1h3PTqK8x/4XXo3/PnJ/wB/0/xpP+F2aN/z5yf9/wBP8aOVh7aHc5P48f8AIbsP+vRP/Q5a8fr0L4n+J4PFN5a3cEDwCOJYtjsCTguc8dvmFee1pHY4ajTm2goooqiAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAsWtnLdsRGMAfecg7R1xk++K6C0sYrUZGWY4yx9PT6Z5rI0y3lMwmDMkCt80nTOO3681el1mLyJxGXV+kZHBbtn270AZN5MZ7qSTjBOAQMZA4FQUlLSGJRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB0lg4utNVXO5SvluvY4PH9Kzb/S2t1aWNt0Yx1+9/8AXpNKvUtTKsudhG4Y55Hb8atXLDVLHfDnzI+TFnn/AOv7fjQIw6KKKYBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABUtvbvczpDHjcxwMnFRVtIo0uwLsMzzrhPl6fn+GaAEv5I7O0WwhDLMMGVxxkY6fjx36cVj4qQsWYsxJYnJJ7000ANp1FFAxtFLijFACUUuKMUAJRS4oxQAlFLijFACUUuKMUAJRS4oxQAlFLijFAAKtWV29pOGDERscSADOR/jVUCl7UAaOoWSqoubcZgb72P4T/h/n0rMrS02+EbtBJgRSggkkjGRg8+/Sq99ZmzuNnJQ8qSOtAFWiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKBCUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRVqwtGu7gLhtinLsvYUAW9NtkSN7yY4SPlARjJ9eePYe9Urq4a6uGlPAPRc9BVjU7wTyiKIYhiJCgd/y4x6VRoASiiigBcmjJpKKBhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFa1tMNQtvsk7bWQARkfp+X8s1k0+OQxOrrwysGBx0IoAJomglaNxhh1FMrZmRdUtRcL/r0GCiknjPp+Z/TmsagBeKOKSigAooooAKKKKACiiigAooooAKKKKACiiigAooooEJRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUASQwvPKscalnY4AFat5Iun2a2cTFncEy5PQn/AB/lRZpHp9s89wg+0Mp8tSMkfh29/b8qynkaRizcknJ+poAjooooAKKKKAFooooGFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAWLO7eyn81ADxgg9xVq/tgw+1wcwvyf8AZJ/yaza0dMuwjvbylVhlGCWPQ/X3oAzqKt39qbW42jcUPKsR1qpQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUCEooooAKKKKACiiigAooooAKKKKACiiigAooooAkhhedtkY3PgkDPXAJP8AKr2mW0fN1cgeQnqe/wDn+lT6JBzJOcjooIP4n+lXNTRGsZN8xjx0HZj6H/P8qAMa+u3uptzPlB9wdMVUoooASiiigAooooAWiiigYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAa9tMNTgFlMdpjGY2GBwOOnc/z5+tZsltLHIyMuGUkEemP/AK1FvGZZ1RZFRieGY4Ga6qMbDvO0yYwWx/n3oA5HFGKnuYvIuZI8EbWOMnPHaoqAG4NGDTuKOKAGUUuRRkUAJRS5FGRQAlFLmjNACUU7NITxQAlFFFAhKKKKACiiigApVUsQACSTgADrSVYsv+P23/66r/OgBPsV1/z7Tf8Afs0fYrr/AJ9pv+/Zr698MeF9AuPCejzz6Jpss0tjC7ySWkbMzGNckkrkknmtf/hEfDf/AEL+lf8AgFF/8TWEq8U7E8x8V/Y7n/n2m/74NH2O5/59pv8Avg19qf8ACJeG/wDoX9K/8Aov/iaP+ES8N/8AQv6V/wCAUX/xNH1iPYOY+K/sdz/z7Tf9+zR9juv+fab/AL9mvtT/AIRLw3/0L+lf+AUX/wATR/wiXhv/AKF/Sv8AwCi/+Jo+sR7BzHxX9juv+fab/v2aPsd1/wA+03/fs19qf8Il4b/6F/Sv/AKL/wCJo/4RLw3/ANC/pX/gFF/8TR9Yj2DmPkdZJLDT0jhtnkkKbjhCQpPr9On4Vk3AvLqUyyQSc9AEOFHoK+zT4R8Nk5/4R/Sv/AKL/wCJpR4S8NgAf8I/pXH/AE5Rf/E0fWI9g5j4r+x3P/PCX/vg0fY7n/nhL/3wa+1P+ES8N/8AQv6V/wCAUX/xNH/CJeG/+hf0r/wCi/8AiaPrEewcx8V/Y7n/AJ4S/wDfBo+x3P8Azwl/74Nfan/CJeG/+hf0r/wCi/8AiaP+ES8N/wDQv6V/4BRf/E0fWI9g5j4r+x3P/PCX/vg0fY7n/nhL/wB8GvtT/hEvDf8A0L+lf+AUX/xNH/CJeG/+hf0r/wAAov8A4mj6wuwcx8USxPCwV1ZSRnDLg0yun+IMMVv451aCGNY44ruZERFwqqJGAAHYVzFbJ3VywooopgFFFFABRRRQAUUUUAFFFFABRRRQAUUUUASpbzSpujhkYZxlVJFO+x3X/PvL/wB8GvUfgfYWmo6zew31tDcwrbu4jmjDruDRjOD3wT+de5f8Iv4d/wCgDpn/AICR/wCFaRpuSuZyqKLsz47+yXP/AD7y/wDfBo+yXP8Az7y/98GvsP8A4Rbw7/0AtM/8BI/8KP8AhFvDv/QC0z/wET/Cq9iyfao+PPslz/z7y/8AfBo+yXP/AD7y/wDfBr7D/wCEW8O/9AHTP/ASP/Cj/hFvD3/QB0z/AMBI/wDCj2LD2yPjz7Jc/wDPvL/3wa0rG6vIAsdxDM0KjAHlnK+lfWP/AAivh7/oA6Z/4CR/4U4eFvDoBH9haZz/ANOkf+FHsWHtUfJmr2zzSRzRIWLDBwvJ9D6//qrP+x3f/PrN/wB8GvsL/hFfDv8A0AtM/wDASP8Awpf+EV8O/wDQC0z/AMBE/wAKPYsPbI+O/sV3/wA+03/fBo+xXf8Az7Tf98GvsL/hF/D3/QB0z/wEj/wo/wCEX8Pf9AHTP/AWP/Cj2LD2yPjz7Hd/8+03/fs0fY7v/n2m/wC/Zr7E/wCEX8Pf9AHTP/ASP/Cj/hF/D3/QB0z/AMBI/wDCj2LD2qPjv7Hd/wDPtN/37NH2K7/59pv+/Zr7E/4Rfw9/0AdM/wDASP8Awo/4Rfw9/wBAHTP/AAEj/wAKPYsPao+PPslyqszW8wUDJJQ4AqHtX0V8YdG0vTfBImsNNs7WVrkIzwwKhK+XJxkDpwK+dKylHldi07q4UlBopFC0UUUAJRRRQAUUUUAFWLL/AI/bf/rqv86r1Ysv+P23/wCuq/zoA+0vCn/ImaF/2D4P/Ra1sVj+FP8AkTNC/wCwfB/6LWtivNl8TM2FFFFCJCiiimMKKKKACiiigAooooAKKKKACiiigEfG/wASP+Sga3/1+z/+jXrla6r4kf8AJQNb/wCv2f8A9GvXK13w+E1QtFFFUMKKKKACiiigAooooAKKKKACiiigAooooA9g+AnGv33/AF6yf+hxV9AV8/8AwE/5D99/16v/AOhxV9AV1UlaJz1dwooorUyEooNFAgooooAMmjNFFABRRRQAUUUUAFFGKWgDzj43f8iEn/X2v/ouSvmevpj43f8AIhJ/19r/AOi5K+Z65a251Q2EooorIoSiiigYUUUUAFFFFABViy/4/bf/AK6r/Oq9WLL/AI/bf/rqv86APtLwl/yJmhf9g+D/ANFitisfwj/yJmh/9g+D/wBFitivNn8TICiiikSFFeRaZDbeK9LvvFHiKz1TVi100MGn2W5vITjGFVl9eefTrmqvii+0bUPhho7aZDdppcWqrGUujl1XEhbkEkjn1zWqh0A9norxe2js1uPETeFVuR4d/sOcS+Zv8rzSrY2h+c9P17VvA/8AFiuo/wCPP/2pQ4gejefF54g82PzmXeI93zFc4Jx6cj86rDWdLP8AzErT/j4+y/65f9d/zz6/f/2eteaG4sY5PCK6lZXFqg0YmDV7W62OqrbbnGxVJO3jHueh5FcN9r0kwE/8JFqnPiDzT87cQf8APx9z/W+/X/ZqlTuB9FXV7a2Kq11dQQKx2qZZAgJ9Bn61R/4SfQP+g3pv/gXH/jXj+o/Yr74haM+nHS72O4jAW51Iyk3G2PywbgMAA+6M7dqjJwT1rLC2B8OnRvtvhksRgXg0+6+0/f3f6zy/w6dOKXswPokEMoYEEHkEUVBYXEV3ptrcwtvhmiWRGwRlSAQcHBHHqKsVDVgEooopAj43+JH/ACUDW/8Ar9n/APRr1ytdn4+sZ7vx9rTRqNv22cFicAHzW/GsmDRUjYNM5cgjgcDPp7/pXfH4UamHRWvf6XIZI/ssA2BMH5h1/Gqn9lXv/PH/AMfX/GqGU6Kuf2Ve/wDPH/x9f8aP7Kvf+eP/AI+v+NAFOirn9lXv/PH/AMfX/Gj+yr3/AJ4/+Pr/AI0AU6Kuf2Ve/wDPH/x9f8aP7Kvf+eP/AI+v+NAFOirn9lXv/PH/AMfX/Gj+yr3/AJ4/+Pr/AI0AU6Kuf2Ve/wDPH/x9f8aP7Kvf+eP/AI+v+NAFOit+y00fZGW5iCv5mQQecYHGR261FcaIGOYJAMDo/wDiP8KAPR/gJ/yMF9/16v8A+hxV7/Xg3wMtpLbxNfxSDkWrnI6H54/8K95rrh8Jz1dwoor570yKwl8P2scFhdQ63PdBLbUDKYol5HG7OCce2eRTcrEKNz6Dorh/FnjOXw3dWGlRPaC8khEktxdiQxr1H3UBYklTVJ/iNey+DrLWLOztzdPqQs5o2DbDlGbK8ggn5evqaOdC5GejVXvL610+Dz7y5gtoQcGSaQIufqTiuVsfFuow67q+ma7a2sTWNmb0PaszDywASMt1PPXjoeK4/wAX614g1vwMmpXVrZR6VczqYVidjMvJ+8Dwc4PTHajnVrj5Wew0VwXiz4hzaFrsumWS2aSW0QklkuxId5IDBECDg4I5PHPbHKXfjrUp4fDM+mafbu+sGVGhnJ+V1IXgjHGc5JB4p86FyO1zuzPH5wh8xPOK7xHu+Yj1x6dOfeoP7V07j/iYWnM/2Yfvl/13/PPr9/8A2etcTrV0U1/Sk8Q2P2e5FrOw1TTrtl2gRsz4QKXIHBGe56HkV55HNpQiXOt6oP8Aie7+S/8AqP8Anv8Ac/1v6+1JzHynvlxfWtmoa6uYYFY4UyuFBP4/UVV/4SHRP+g1pv8A4Fp/jXlGoNbX3jrR5tPbTL1ZohsuNQ83M4VfLzOGGN26MgbQMkjPUVlbbP8A4R3+xxe+Hv8Ar9/s66+0/e3ff8v8OnTip9oNwse/A5AIOQehFFV7KWO5sbeeGTzIZIlZHwRuUgEHB5HHrVirTuSecfG7/kQk/wCvtf8A0XJXzPX0x8bv+RCT/r7X/wBFyV8z1z1tzohsJRRRWRYlFFFABRRRQAUUUUAFWLL/AI/bf/rqv86r1Ysv+P23/wCuq/zoA+0vCP8AyJmhf9g+D/0WK2Kx/CP/ACJmhf8AYPg/9FitivNn8TICiiikScZ/wg11p+oXVz4e8Q3GlR3bGSa38hZkLnqyhvu//W+lVm+GkQ8KWOhw6o6ra3y3pmeHcXIDArjcMDn1Nd5RT52BDc28dzbyQTLuilRo3U9GUjBFcGPhpcfZBpZ8T3v9iCTd9iEYBxnO3fnpnnp74r0KjFNTaA4PxFoniCTxHpd5ottaCz0i3YW6PLteUyKY2UHsQoBGeOnXtzsOieJYdE0vTI/B8pWw1Bb8SnVoC0jgsQG498fhXrpoqvaeRNzzXWPC9xqXiPStZuPDwmuJ0uZL20a5V0VlhVYYy+MDJXrjgk1gnwp4w/t3+0vsOsH/AEfycnxDH53XP+t2/d/2cdec17PilHFP2rC5XsHuJLC3e6gNvcGNTJCZBIUbuNw6/XvVqkFLUt3KEooopAj47+IsjR/EPW2QkEXs/IOP+Wr1hQ6xcxsCxEgwB83XH1rb+JH/ACUDXP8Ar9n/APRrVytd8fhRqWtQuxeTJKEK/Jggn3NVKXijj1qhiUUUUAFFFFABRRRQAUUUUAFFFFAGlZaglnasuxnZpM46DGPWo59UuZuCwQYxiMY/XrVLiigD2L4BsW8Q35Pe1cnPrvjr32vAPgH/AMjBff8AXo//AKHFXv8AXXT+E56u4VxcHw9t08GS+Hp73zi0hljuRFtMb9jtyf58gmu0oqrJ7mabWxyl34QvLhtOvYtdkg1iyhMP21YAwkX/AGkJxnk9+pJp+q+FLrWNFsbG81qSWe3u1uXuXgH7wjdxtBAUfN+ldRRRyofNI55/C8c3ii+1ee6MkN5Ymye28vHynGTuz6DpjvXPT/DO6uNDXRpPE1w1hE+63ha3UhOT94ggt1PcD2r0KiiyDmZy+q+E7q5159Z0rWpNMu5YhFPi3WVZAOhw3fAAz7VPfeGZb/UNAvJtRZ5NKLFmeLJuCQuScEBfu+h610NFLlQnKRxniTS/El34qstR063tXh02FvJDybGmeUFXGexAAI7c965230jxFb6Pp+nL4TlVbO/F95ranCWlYEnDce+OPSvVqDS5UCbR5zqXhu41LxHpWsz6F581wtxJe2rTB0VlhCxRl8YwSvXGMk1if8Ix4p/tlb82OrbVt/Jz/bsfndc/6zH3f9nHXnNev4o59aORD5mV7BpnsYHuITDM0amSMuH2Njkbh1+tWaKKpKwjzf43f8iGn/X2v/ouSvmevpj43f8AIhp/19r/AOi5K+Z656250Q+EKKKKyLEooooAKKKKACiiigAqxZf8ftv/ANdV/nVerFl/x+2//XVf50AfaXhH/kTNC/7B8H/osVsVj+Ef+RM0L/sHwf8AosVsV5sviZm3YKKKKRIUUUUDCiiigQUYoooEJSikpaBBRRRTGFFFFMpHxv8AEj/koOuf9f0//o165Wuq+I//ACUHXP8Ar+n/APRr1ytd8fhRqLRRRVDCiiigAooooAKKKKACiiigAooooAKKKKAPYfgH/wAh++/69H/9Dir3+vAPgH/yH77/AK9H/wDQ4q9/rrp/Cc9XcKKKK0MgooooAKKKKQBRRRQAUUUUAFFFFABRRRQB5v8AG7/kQ0/6+1/9FyV8z19MfG7/AJENP+vtf/RclfM9c1bc6YbBRRRWRYlFFFABRRRQAUUUUAFT2jBbuFmIAEikk9uagooA+i9F+Nuj6Xoen6e9jJI1rbRwl1uEAYqoGcH6Vd/4X1ov/QOl/wDAiP8Axr5ooqPZQfQXKj6X/wCF9aL/ANA6X/wIj/xo/wCF9aL/ANA6X/wIj/xr5oopeyh2DlR9L/8AC+tF/wCgdL/4ER/40f8AC+tF/wCgdL/4ER/4180UUeyh2DlR9L/8L60X/oHS/wDgRH/jR/wvrRf+gdL/AOBEf+NfNFFHsodhcqPpf/hfWi/9A6X/AMCI/wDGj/hfWi/9A6X/AMCI/wDGvmiij2UOwcqPpj/hfei/9A6X/wACY/8AGj/hfei/9A6X/wACY/8AGvmaij2UOw+VH0z/AML70X/oHS/+BMf+NH/C+9F/6B0v/gTH/jXzNRR7KHYOVH0z/wAL70X/AKB0v/gTH/jR/wAL70X/AKB0v/gRH/jXzNRR7KHYOVG/4x1KHWPFF9qUHEd1PJMF3A7QzscZH1rBpKK0SsMKKKKYC0UUUDCiiigAooooAKKKKACiiigAooooA9A+GXi6z8IXtzeXSeb5kTRCMOFPJQ557fLXpv8AwvHRf+fGT/v+lfONLVKckrIhwTep9G/8Lx0X/nxk/wC/6Uf8Lx0X/nxk/wC/6V85UUc8+4vZxPo3/heOi/8APjJ/3/Sj/heOi/8APjJ/3/SvnKijnn3D2cT6N/4Xjov/AD4yf9/0o/4Xjov/AD4yf9/0r5yoo559w9nE+jf+F46L/wA+Mn/f9KP+F46L/wA+Mn/f9K+cqKOefcPZxPo3/heOi/8APjJ/3/Sj/heOi/8APjJ/3/SvnKijnn3D2cT6N/4Xjov/AD4yf9/0o/4Xjov/AD4yf9/0r5yoo559w9nE+jf+F46L/wA+Mn/f9KP+F46L/wA+Mn/f9K+cqSj2k+4ezieyfED4k6Z4t8Nf2dbwNDIkvnbmlU5wjDGB/vV45RRUyblqylFJWQUUUUhiUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUwCiiigBaKKKBhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAlGaKKQgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKYBRRRQAtFFFAwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooopCP//Z" alt="img"></p> <p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。<br>
这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。<br>
如果这一块要深挖，建议去读一些浏览器内核源码解析文章。</p> <div class="tip custom-block"><p>（三）梳理浏览器内核中线程之间的关系</p></div> <p>到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念：<br> <strong>GUI 渲染线程与 JS 引擎线程互斥</strong><br>
由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起， GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。
<strong>JS 阻塞页面加载</strong><br>
从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。
譬如，假设 JS 引擎正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中，等待 JS 引擎空闲后执行。 然后，由于巨量计算，所以 JS 引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。
所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
<strong>WebWorker，JS 的多线程？</strong><br>
前文中有提到 JS 引擎是单线程的，而且 JS 执行时间过长会阻塞页面，那么 JS 就真的对 cpu 密集型计算无能为力么？<br>
所以，后来 HTML5 中支持了 Web Worker。<br>
MDN 的官方解释是：</p> <div class="warning custom-block"><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面</p> <p>一个 worker 是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的 JavaScript 文件</p> <p>这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的 window 因此，使用 window 快捷方式获取当前全局的范围 (而不是 self) 在一个 Worker 内将返回错误</p></div> <p>这样理解下：</p> <ul><li>创建 Worker 时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM）</li> <li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）<br>
所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!
而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。<br>
其它，关于 Worker 的详解就不是本文的范畴了，因此不再赘述。<br> <strong>WebWorker 与 SharedWorker</strong><br>
既然都到了这里，就再提一下 SharedWorker（避免后续将这两个概念搞混）</li></ul> <ol><li>WebWorker 只属于某个页面，不会和其他页面的 Render 进程（浏览器内核进程）共享</li></ol> <ul><li>所以 Chrome 在 Render 进程中（每一个 Tab 页就是一个 render 进程）创建一个新的线程来运行 Worker 中的 JavaScript 程序。</li></ul> <ol start="2"><li>SharedWorker 是浏览器所有页面共享的，不能采用与 Worker 同样的方式实现，因为它不隶属于某个 Render 进程，可以为多个 Render 进程共享使用。</li></ol> <ul><li>所以 Chrome 浏览器为 SharedWorker 单独创建一个进程来运行 JavaScript 程序，在浏览器中每个相同的 JavaScript 只存在一个 SharedWorker 进程，不管它被创建多少次。
看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker 由独立的进程管理，WebWorker 只是属于 render 进程下的一个线程<div class="tip custom-block"><p>（四）简单梳理下浏览器渲染流程</p></div>
本来是直接计划开始谈 JS 运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到 JS 可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）<br>
为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）</li> <li>浏览器输入 url，浏览器主进程接管，开一个下载线程， 然后进行 http 请求（略去 DNS 查询，IP 寻址等等操作），然后等待响应，获取内容， 随后将内容通过 RendererHost 接口转交给 Renderer 进程</li> <li>浏览器渲染流程开始</li></ul> <p><strong><em>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</em></strong></p> <ol><li>解析 html 建立 dom 树</li> <li>解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）</li> <li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li> <li>绘制 render 树（paint），绘制页面像素信息</li> <li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。
所有详细步骤都已经略去，渲染完毕后就是 load 事件了，之后就是自己的 JS 逻辑处理了<br>
既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。<br>
这里重绘参考来源中的一张图：（参考来源第一篇）</li></ol> <p><img src="/assets/img/x8.c2ba7b32.jpg" alt="img"></p> <p><strong>load 事件与 DOMContentLoaded 事件的先后</strong>
上面提到，渲染完毕后会触发 load 事件，那么你能分清楚 load 事件与 DOMContentLoaded 事件的先后么？<br>
很简单，知道它们的定义就可以了：</p> <ul><li>当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。 (譬如如果有 async 加载的脚本就不一定完成)</li> <li>当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）
所以，顺序是：DOMContentLoaded -&gt; load<br> <strong>css 加载是否会阻塞 dom 树渲染？</strong><br>
这里说的是头部引入 css 的情况<br>
首先，我们都知道：<strong>css 是由单独的下载线程异步下载的。</strong><br>
然后再说下几个现象：</li> <li>css 加载不会阻塞 DOM 树解析（异步加载时 DOM 照常构建）</li> <li>但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）
这可能也是浏览器的一种优化机制。<br>
因为你加载 css 的时候，可能会修改下面 DOM 节点的样式， 如果 css 加载不阻塞 render 树渲染的话，那么当 css 加载完之后， render 树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把 DOM 树的结构先解析完，把可以做的工作做完，然后等你 css 加载完之后， 在根据最终的样式来渲染 render 树，这种做法性能方面确实会比较好一点。
<strong>普通图层和复合图层</strong>
渲染步骤中就提到了 composite 概念。<br>
可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层<br>
首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）<br>
其次，absolute 布局（fixed 也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。
然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）<br>
可以简单理解下：GPU 中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒<br>
可以 Chrome 源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders 中看到，黄色的就是复合图层信息<br>
如下图。可以验证上述的说法
<img src="/assets/img/x9.ab61b973.jpg" alt="img"></li></ul> <p><strong>如何变成复合图层（硬件加速）</strong>
将该元素变成一个复合图层，就是传说中的硬件加速技术</p> <ul><li>最常用的方式：translate3d、translateZ</li> <li>opacity 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li> <li>will-chang 属性（这个比较偏僻），一般配合 opacity 与 translate 使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li> <li>\video\iframecanvas 等元素</li> <li>其它，譬如以前的 flash 插件
<strong>absolute 和硬件加速的区别</strong>
可以看到，absolute 虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算 absolute 中信息改变时不会改变普通文档流中 render 树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以 absolute 中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute 带来的绘制信息变化过大，资源消耗是非常严重的）<br>
而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）<br> <strong>复合图层的作用？</strong>
一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能<br>
但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡<br> <strong>硬件加速时请使用 index</strong><br>
使用硬件加速时，尽可能的使用 index，防止浏览器默认给后续的元素创建复合层渲染
具体的原理时这样的：<strong>webkit CSS3 中，如果这个元素添加了硬件加速，并且 index 层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且 releative 或 absolute 属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能</strong><br>
简单点理解，其实可以认为是一个隐式合成的概念：**如果 a 是一个复合图层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，**这点需要特别注意<br>
另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：
web.jobbole.com/83575/</li></ul> <div class="tip custom-block"><p>（五）从 Event Loop 谈 JS 的运行机制</p></div> <p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS 引擎的一些运行机制分析。<br>
注意，这里不谈可执行上下文，VO，scop chain 等概念（这些完全可以整理成另一篇文章了），这里主要是结合 Event Loop 来谈 JS 代码是如何执行的。<br>
读这部分的前提是已经知道了 JS 引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p> <ul><li>JS 引擎线程</li> <li>事件触发线程</li> <li>定时触发器线程
然后再理解一个概念：</li> <li>JS 分为同步任务和异步任务</li> <li>同步任务都在主线程上执行，形成一个执行栈</li> <li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li> <li>一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。
看图：
<img src="/assets/img/x10.db0a5229.jpg" alt="img"></li></ul> <p>看到这里，应该就可以理解了：为什么有时候 setTimeout 推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。</p> <p><strong>事件循环机制进一步补充</strong><br>
这里就直接引用一张图片来协助理解：（参考自 Philip Roberts 的演讲《Help, I'm stuck in an event-loop》）<br> <img src="/assets/img/x11.6902cead.jpg" alt="img">
上图大致描述就是：</p> <ul><li>主线程运行时会产生执行栈， 栈中的代码调用某些 api 时，它们会在事件队列中添加各种事件（当满足触发条件后，如 ajax 请求完毕）</li> <li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li> <li>如此循环</li> <li>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件
单独说说定时器<br>
上述事件循环机制的核心是：JS 引擎线程和事件触发线程<br>
但事件上，里面还有一些隐藏细节，譬如调用 setTimeout 后，是如何等待特定时间后才添加到事件队列中的？<br>
是 JS 引擎检测的么？当然不是了。它是由定时器线程控制（因为 JS 引擎自己都忙不过来，根本无暇分身）<br>
为什么要单独的定时器线程？因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。<br>
什么时候会用到定时器线程？当使用 setTimeout 或 setInterval 时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。<br>
譬如:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码的作用是当 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;begin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行<br> <strong>注意：</strong></p> <ul><li>执行结果是：先 begin 后 hello!</li> <li>虽然代码的本意是 0 毫秒后就推入事件队列，但是 W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 (不过也有一说是不同浏览器有不同的最小时间设定)</li> <li>就算不等待 4ms，就算假设 0 毫秒就推入事件队列，也会先执行 begin（因为只有可执行栈内空了后才会主动读取事件队列）
setTimeout 而不是 setInterval<br>
用 setTimeout 模拟定期计时和直接用 setInterval 是有区别的。<br>
因为每次 setTimeout 计时到后就会去执行，然后执行一段时间后才会继续 setTimeout，中间就多了误差 （误差多少与代码执行时间有关）<br>
而 setInterval 则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）<br>
而且 setInterval 有一些比较致命的问题就是：</li> <li>累计效应（上面提到的），如果 setInterval 代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个 setInterval 的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li> <li>譬如像 IOS 的 webview，或者 Safari 等浏览器中都有一个特点，<strong>在滚动的时候是不执行 JS 的</strong>，如果使用了 setlnterval，会发现在滚动结束后会执行多次由于滚动不执行 JS 积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（这一块欢迎大家后续补充，setInterval 自带的优化，不会重复添加回调）</li> <li>而且把浏览器最小化显示等操作时，setInterval 并不是不执行程序， 它会把 setInterval 的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时<br>
所以，鉴于这么多但问题，目前一般认为的最佳方案是：用 setTimeout 模拟 setInterval，或者特殊场合直接用 requestAnimationFrame<br>
补充：JS 高程中有提到，JS 引擎会对 setInterval 进行优化，如果当前事件队列中有 setInterval 的回调，不会重复添加。不过，仍然是有很多问题。。。<div class="tip custom-block"><p>（六）事件循环进阶：macrotask 与 microtask</p></div>
这段参考了参考来源中的第 2 篇文章（英文版的），（加了下自己的理解重新描述了下）， 强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：<br>
jakearchibald.com/2015/tasks-…<br>
上文中将 JS 事件循环机制梳理了一遍，在 ES5 的情况是够用了，但是在 ES6 盛行的现在，仍然会遇到一些问题，譬如下面这题：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它的正确执行顺序是这样子的：</p> <div class="language-js extra-class"><pre class="language-js"><code>script start
script end
promise1
promise2
setTimeout
</code></pre></div><p>为什么呢？因为 Promise 里有了一个一个新的概念：microtask<br>
或者，进一步，JS 中分为两种任务类型：macrotask 和 microtask，在 ECMAScript 中，microtask 称为 jobs，macrotask 可称为 task<br>
它们的定义？区别？简单点可以按如下理解：</p> <ol><li>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li></ol> <ul><li>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它</li> <li>浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;...）</li></ul> <ol><li>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</li></ol> <ul><li>也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前</li> <li>所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染</li> <li>也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）<br> <strong>分别很么样的场景会形成 macrotask 和 microtask 呢？</strong></li> <li>macrotask：主代码块，setTimeout，setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask）</li> <li>microtask：Promise，process.nextTick 等
<strong><em>补充：在 node 环境下，process.nextTick 的优先级高于 Promise</em></strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的 nextTickQueue 部分，然后才会执行微任务中的 Promise 部分。<br>
参考：segmentfault.com/q/101000001…<br> <strong>再根据线程来理解下：</strong></li> <li>macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</li> <li>microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）<br>
所以，总结下运行机制：</li> <li>执行一个宏任务（栈中没有就从事件队列中获取）</li> <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li> <li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li> <li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）
如图：
<img src="/assets/img/x12.fe154a20.jpg" alt="img"></li></ul> <p>另外，请注意下 Promise 的 polyfill 与官方版本的区别：</p> <ul><li>官方版本中，是标准的 microtask 形式</li> <li>polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式
请特别注意这两点区别<br>
注意，有一些浏览器执行结果不一样（因为它们可能把 microtask 当成 macrotask 来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）
<strong>20180126 补充：使用 MutationObserver 实现 microtask</strong>
MutationObserver 可以用来实现 microtask （它属于 microtask，优先级小于 Promise， 一般是 Promise 不支持时才会这样做）<br>
它是 HTML5 中的新特性，作用是：监听一个 DOM 变动， 当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知<br>
像以前的 Vue 源码中就是利用它来模拟 nextTick 的， 具体原理是，创建一个 TextNode 并监听内容变化， 然后要 nextTick 的时候去改一下这个节点的文本内容， 如下：（Vue 的源码，未修改）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">1</span>var observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>nextTickHandler<span class="token punctuation">)</span>
<span class="token keyword">var</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span>

observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>    characterData<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span>
    textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对应 Vue 源码链接<br>
不过，现在的 Vue（2.5+）的 nextTick 实现移除了 MutationObserver 的方式（据说是兼容性原因）， 取而代之的是使用 MessageChannel （当然，默认情况仍然是 Promise，不支持才兼容的）。<br>
MessageChannel 属于宏任务，优先级是：MessageChannel-&gt;setTimeout， 所以 Vue（2.5+）内部的 nextTick 与 2.4 及之前的实现是不一样的，需要注意下。<br>
这里不展开，可以看下 juejin.im/post/5a1af8…</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Reprint/原理基础/huancun.html" class="prev">
          浏览器HTTP缓存机制
        </a></span> <span class="next"><a href="/Reprint/原理基础/web.html">
          一篇文章理解 Web 缓存
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c18ba2b.js" defer></script><script src="/assets/js/2.2d7f6841.js" defer></script><script src="/assets/js/7.8c724b93.js" defer></script>
  </body>
</html>
