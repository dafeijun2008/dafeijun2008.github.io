<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>V8 内存浅析 | Dajun</title>
    <meta name="description" content="笔记">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.7f3e8fa0.css" as="style"><link rel="preload" href="/assets/js/app.3c18ba2b.js" as="script"><link rel="preload" href="/assets/js/2.2d7f6841.js" as="script"><link rel="preload" href="/assets/js/6.5bb0aa3d.js" as="script"><link rel="prefetch" href="/assets/js/10.4e623ea8.js"><link rel="prefetch" href="/assets/js/11.1b2a7179.js"><link rel="prefetch" href="/assets/js/12.8062ade3.js"><link rel="prefetch" href="/assets/js/13.edc49012.js"><link rel="prefetch" href="/assets/js/14.e84ee3f4.js"><link rel="prefetch" href="/assets/js/15.e8d4142b.js"><link rel="prefetch" href="/assets/js/16.40a39847.js"><link rel="prefetch" href="/assets/js/17.1c075161.js"><link rel="prefetch" href="/assets/js/18.34b4e583.js"><link rel="prefetch" href="/assets/js/19.7f97ee03.js"><link rel="prefetch" href="/assets/js/20.aabac5c0.js"><link rel="prefetch" href="/assets/js/21.d261013f.js"><link rel="prefetch" href="/assets/js/22.b7560755.js"><link rel="prefetch" href="/assets/js/23.eb76ccea.js"><link rel="prefetch" href="/assets/js/24.6d592b30.js"><link rel="prefetch" href="/assets/js/25.b30f5339.js"><link rel="prefetch" href="/assets/js/26.8efe380d.js"><link rel="prefetch" href="/assets/js/27.94f1d5b7.js"><link rel="prefetch" href="/assets/js/28.4d86e4cc.js"><link rel="prefetch" href="/assets/js/29.2b342c8d.js"><link rel="prefetch" href="/assets/js/3.976ff7bf.js"><link rel="prefetch" href="/assets/js/30.68cd5081.js"><link rel="prefetch" href="/assets/js/31.fef0ba54.js"><link rel="prefetch" href="/assets/js/32.baa6441c.js"><link rel="prefetch" href="/assets/js/33.9c22ff1b.js"><link rel="prefetch" href="/assets/js/34.a08208a6.js"><link rel="prefetch" href="/assets/js/35.f0d94ae9.js"><link rel="prefetch" href="/assets/js/36.8f885fc3.js"><link rel="prefetch" href="/assets/js/37.7fd3e68c.js"><link rel="prefetch" href="/assets/js/38.bd73a7cf.js"><link rel="prefetch" href="/assets/js/39.2dca5b84.js"><link rel="prefetch" href="/assets/js/4.ab25bdf6.js"><link rel="prefetch" href="/assets/js/40.e324d414.js"><link rel="prefetch" href="/assets/js/41.32b91a1c.js"><link rel="prefetch" href="/assets/js/42.fee64b88.js"><link rel="prefetch" href="/assets/js/43.fc4fcb6c.js"><link rel="prefetch" href="/assets/js/44.3aeab9ce.js"><link rel="prefetch" href="/assets/js/45.811463a8.js"><link rel="prefetch" href="/assets/js/46.94aea5ef.js"><link rel="prefetch" href="/assets/js/47.2863ce6a.js"><link rel="prefetch" href="/assets/js/48.4239ef8f.js"><link rel="prefetch" href="/assets/js/49.7e48151d.js"><link rel="prefetch" href="/assets/js/5.c62fc94e.js"><link rel="prefetch" href="/assets/js/7.8c724b93.js"><link rel="prefetch" href="/assets/js/8.d40cf774.js"><link rel="prefetch" href="/assets/js/9.a84cb03a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f3e8fa0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dajun</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link router-link-active">转载</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link router-link-active">转载</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>原理</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Reprint/%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/" class="sidebar-link">那些前端应该知道的HTTP知识</a></li><li><a href="/Reprint/原理基础/huancun.html" class="sidebar-link">浏览器HTTP缓存机制</a></li><li><a href="/Reprint/原理基础/xiancheng.html" class="sidebar-link">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></li><li><a href="/Reprint/原理基础/web.html" class="sidebar-link">一篇文章理解 Web 缓存</a></li><li><a href="/Reprint/原理基础/v8.html" class="sidebar-link">V8 引擎</a></li><li><a href="/Reprint/原理基础/yinqing.html" class="sidebar-link">JS 引擎的执行机制</a></li><li><a href="/Reprint/原理基础/v8neicun.html" class="active sidebar-link">V8 内存浅析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="v8-内存浅析"><a href="#v8-内存浅析" aria-hidden="true" class="header-anchor">#</a> V8 内存浅析</h2> <p>WQTech  2018-11-22</p> <p>简介</p> <ul><li>V8 内存构成</li> <li>V8 垃圾生命周期（垃圾回收）</li> <li>使用 Chrome 调优前端代码</li> <li>使用 alinode 调优 node.js 进程</li></ul> <h4 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h4> <p>V8 是谷歌开发的高性能 JavaScript 引擎，该引擎使用 C++ 开发。目前主要应用在 Google Chrome 浏览器和 node.js 当中。</p> <p>V8 自带的高性能垃圾回收机制，使开发者能够专注于程序开发中，极大的提高开发者的编程效率。但是方便之余，也会出现一些对新手来说比较棘手的问题：进程内存暴涨，cpu 飙升，性能很差等。这个时候，了解 V8 的内存结构和垃圾回收机制、知道如何进行性能调优就很有必要。本文主要讲述 V8 的内存管理和垃圾回收，后面会用示例代码结合 Chrome 的开发者工具进行分析；最后介绍了阿里的 node.js 应用服务解决方案 alinode。</p> <h4 id="v8-内存构成"><a href="#v8-内存构成" aria-hidden="true" class="header-anchor">#</a> V8 内存构成</h4> <p>一个 V8 进程的内存通常由以下几个块构成：</p> <ol><li>新生代内存区（new space）
大多数的对象都会被分配在这里，这个区域很小但是垃圾回收比较频繁；</li> <li>老生代内存区（old space）
属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针；</li> <li>大对象区（large object space）
这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象区；</li> <li>代码区（code space）
代码对象，会被分配在这里。唯一拥有执行权限的内存；</li> <li>map 区（map space）
存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li></ol> <p>内存构成可以用下图来表示：</p> <p><img src="/assets/img/q1.f9067d88.jpg" alt="img"></p> <p>其中带斜纹的是对应的内存块中未使用的内存空间。new space 通常很小（1~8M），它被分成了两部分，一部分叫做 inactive new space，一部分是激活状态，为啥会有激活和未激活之分的原因，下面会提到。old space 偏大，可能达几百兆。</p> <h4 id="v8-内存生命周期"><a href="#v8-内存生命周期" aria-hidden="true" class="header-anchor">#</a> V8 内存生命周期</h4> <p>假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：</p> <ol><li><p>这个对象被分配到了 new space；</p></li> <li><p>随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；</p></li> <li><p>gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；</p></li> <li><p>随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。
第二步里，清理 new space 的过程叫做 Scavenge，这个过程采用了空间换时间的做法，用到了上面图中的 inactive new space，过程如下：</p></li> <li><p>当活跃区满了之后，交换活跃区和非活跃区，交换后活跃区变空了；</p></li> <li><p>将非活跃区的两次清理都没清理出去的对象移动到 old space；</p></li> <li><p>将还没清理够两次的但是活跃状态的对象移动到活跃区。
第四步里，清理 old space 的过程叫做 Mark-sweep ，这块占用内存很大，所以没有使用 Scavenge，这个回收过程包含了若干次标记过程和清理过程：</p></li> <li><p>标记从根（root）可达的对象为黑色；</p></li> <li><p>遍历黑色对象的邻接对象，直到所有对象都标记为黑色；</p></li> <li><p>循环标记若干次；</p></li> <li><p>清理掉非黑色的对象。
简单来说，<strong>Mark-sweep 就是把从根节点无法获取到的对象清理掉了。</strong></p></li></ol> <p>使用 Chrome 调优前端代码</p> <blockquote><p>注：本文截图里的 Chrome 版本为 Version 64.0.3282.140 (Official Build) (64-bit)
<strong>1. 查看内容构成</strong></p></blockquote> <p>在控制台获取当前页面的堆内存快照（heap snapshot）：
<img src="/assets/img/q2.4a84eefa.jpg" alt="img"></p> <p>为了便于观看，先在 console 里声明一个类并创建它的一些对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Jane</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Tom</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>jane <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jane</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>   <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Tom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>获取成功后，可以看到一个表格：
<img src="/assets/img/q3.be3f89b5.jpg" alt="img"> <img src="/assets/img/q4.be3f89b5.jpg" alt="img"></p> <p>介绍一下几个关键的列：</p> <ol><li>Constructor：对象的类名；</li> <li>Distance：对象到根的引用层级；</li> <li>Objects Count：对象的数量；</li> <li>Shallow Size： 对象本身占用的内存，不包括引用的对象所占内存；</li> <li>Retained Size： 对象所占总内存，包含引用的其他对象所占内存；</li> <li>Retainers：对象的引用层级关系。
shallow size 和 retained size 的区别可以用红框里的 Tom 和 Jane 更直观的展示：Tom 的 shallow 占了 32M，retained 占用了 56M，这是因为 retained 包括了引用的指针对应的内存大小，即 tom.jane 所占用的内存；所以 Tom 的 retained 总和比 shallow 多出来的 24M 正好跟 Jane 占用的 24M 相同。<strong>retained size 可以理解为当回收掉该对象时可以释放的内存大小，在内存调优中具有重要参考意义。</strong></li></ol> <p><strong>2. 查看对象的引用关系</strong></p> <p>这里使用一个稍复杂的代码来展示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">BList</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token function">push</span> <span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> aArray <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> bList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
aArray<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> bList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>heap snapshot 如下图所示：
<img src="/assets/img/q5.99dc984d.jpg" alt="img"></p> <p>红框中展示了该 B 实例被应用的三个位置，后面的 @?? 可以视为内存的地址，同样的地址意味着同一个对象。可以展开左边的箭头查看，这三个直接引用的地方分别是：</p> <ol><li>Blist.values 对应的指针；</li> <li>A.b 对应的指针；</li> <li>Blist.values 指向的数组的指针。
可以观察到，A 的 retained size 现在和 shallow size 一样了，因为 A 的实例在 aArray 中被引用了；B 的两个 size 也一样了，因为在 A 中和 bList 中都有引用，销毁其本身并不会释放相应的内存。</li></ol> <p><strong>3. 调试内存泄露</strong></p> <p>如果你的网页在放久了的情况下内存越来越大甚至 tab 页崩溃，那就要考虑是否内存泄露了。通过 Chrome 的任务管理器可以看到 JavaScript 所占用的内存：
<img src="/assets/img/q6.34da5eb6.jpg" alt="img"></p> <p>通过 Performance 里的 record 也可以直观地看到内存的增长（需要勾上 Memory 选项）：
<img src="/assets/img/q7.49bb500a.jpg" alt="img"></p> <p>用一个示例代码，结合 heap snapshot 来说明如何排查内存泄露：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre></div><p>这段代码粘贴在控制台后，在控制台的 Memory 页面，隔 10s 取一个 heap snapshot：</p> <p><img src="/assets/img/q9.75610d28.jpg" alt="img"></p> <p>选中第二个和第三个，在选取观察类型的下拉菜单里选择「Comparison」，然后再选择右面的下拉菜单，选择上一个 snapshot：</p> <p><img src="/assets/img/q10.5a675e5b.jpg" alt="img"></p> <p>这个时候后列表中的内容是当前的 snapshot 针对上一个的增加的部分，可以看到图中的 snapshot 14 比 snapshot 13 多出来的部分，跟 snapshot 13 比 snapshot 12 多出来的部分都有 ArrayBuffer，那么就可以确定 ArrayBuffer 导致了内存泄露。这个时候可以结合上面一节的「查看对象引用关系」来定位到类或者代码。</p> <p><strong>使用 alinode 调优 node.js 进程</strong></p> <p>alinode 是阿里云出品的 node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。使用 alinode 来调优 node.js 进程更加直观，便捷，而且具备系统监控、日志服务、nodejs 进程监控、报警等功能，非常强大。</p> <p>使用 alinode 要经过以下步骤：</p> <ol><li>注册阿里云账号；</li> <li>开通 alinode 服务；</li> <li>创建 alinode 应用；</li> <li>在自己服务器上安装 alinode 和 agenthub，配置好自己应用的 id 和 secret；</li> <li>启动自己的 node 进程。
下图是 alinode 某应用的一个实例的控制台：
<img src="/assets/img/q11.fc8f8767.jpg" alt="img"></li></ol> <p>图中圈出来的是常用的几个指标：</p> <ol><li>进程存活时间线：线断了意味着可能进程重启了或者机器网络故障；</li> <li>CPU；</li> <li>内存；</li> <li>GC 时间占比：一分钟内 gc 占用时间的百分比；一般认为小于 5% 属于正常状态，比例很大的话意味着 CPU 需要耗费很多时间在 gc 上，导致进程性能严重下降。这通常对应以下三种情况：</li></ol> <ul><li>进程负载太高，需要增加服务节点；</li> <li>进程内存泄露，导致不停的在 gc；</li> <li>代码需要优化；</li></ul> <ol><li>CPU Profile：火焰图的形式来统计分析；</li> <li>堆快照：可以通过点击「对快照」来生成 heap snapshot，可以下载下来通过 Chrome 来分析，也可以使用 alinode 自带的分析工具：</li></ol> <p><img src="/assets/img/q12.397ab7fc.jpg" alt="img"></p> <p>此外还有一个专门针对内存和 gc 的工具：GC Trace，这个是用来观察 gc 的过程，从而更直观的观察进程 gc 的步骤：</p> <p><img src="/assets/img/q13.94bb6b80.jpg" alt="img"></p> <p>在这里，你可以直观的看到堆大小的变化，可以看到每一次的 GC 是 Scavenge 还是 Mark-Sweep，可以看到每一次 gc 内存堆各类型的大小变化，有了这个强大的分析工具，你可以写出性能更高、更加稳定、响应速度更快的 node.js 代码。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Reprint/原理基础/yinqing.html" class="prev">
          JS 引擎的执行机制
        </a></span> <span class="next"><a href="/Reprint/JS/index2.html">
          js 的 15 种循环遍历，你掌握了几种？
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c18ba2b.js" defer></script><script src="/assets/js/2.2d7f6841.js" defer></script><script src="/assets/js/6.5bb0aa3d.js" defer></script>
  </body>
</html>
