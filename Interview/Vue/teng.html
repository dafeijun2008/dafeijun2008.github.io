<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>腾面试题 | Dajun</title>
    <meta name="description" content="笔记">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.7f3e8fa0.css" as="style"><link rel="preload" href="/assets/js/app.3c18ba2b.js" as="script"><link rel="preload" href="/assets/js/2.2d7f6841.js" as="script"><link rel="preload" href="/assets/js/34.a08208a6.js" as="script"><link rel="prefetch" href="/assets/js/10.4e623ea8.js"><link rel="prefetch" href="/assets/js/11.1b2a7179.js"><link rel="prefetch" href="/assets/js/12.8062ade3.js"><link rel="prefetch" href="/assets/js/13.edc49012.js"><link rel="prefetch" href="/assets/js/14.e84ee3f4.js"><link rel="prefetch" href="/assets/js/15.e8d4142b.js"><link rel="prefetch" href="/assets/js/16.40a39847.js"><link rel="prefetch" href="/assets/js/17.1c075161.js"><link rel="prefetch" href="/assets/js/18.34b4e583.js"><link rel="prefetch" href="/assets/js/19.7f97ee03.js"><link rel="prefetch" href="/assets/js/20.aabac5c0.js"><link rel="prefetch" href="/assets/js/21.d261013f.js"><link rel="prefetch" href="/assets/js/22.b7560755.js"><link rel="prefetch" href="/assets/js/23.eb76ccea.js"><link rel="prefetch" href="/assets/js/24.6d592b30.js"><link rel="prefetch" href="/assets/js/25.b30f5339.js"><link rel="prefetch" href="/assets/js/26.8efe380d.js"><link rel="prefetch" href="/assets/js/27.94f1d5b7.js"><link rel="prefetch" href="/assets/js/28.4d86e4cc.js"><link rel="prefetch" href="/assets/js/29.2b342c8d.js"><link rel="prefetch" href="/assets/js/3.976ff7bf.js"><link rel="prefetch" href="/assets/js/30.68cd5081.js"><link rel="prefetch" href="/assets/js/31.fef0ba54.js"><link rel="prefetch" href="/assets/js/32.baa6441c.js"><link rel="prefetch" href="/assets/js/33.9c22ff1b.js"><link rel="prefetch" href="/assets/js/35.f0d94ae9.js"><link rel="prefetch" href="/assets/js/36.8f885fc3.js"><link rel="prefetch" href="/assets/js/37.7fd3e68c.js"><link rel="prefetch" href="/assets/js/38.bd73a7cf.js"><link rel="prefetch" href="/assets/js/39.2dca5b84.js"><link rel="prefetch" href="/assets/js/4.ab25bdf6.js"><link rel="prefetch" href="/assets/js/40.e324d414.js"><link rel="prefetch" href="/assets/js/41.32b91a1c.js"><link rel="prefetch" href="/assets/js/42.fee64b88.js"><link rel="prefetch" href="/assets/js/43.fc4fcb6c.js"><link rel="prefetch" href="/assets/js/44.3aeab9ce.js"><link rel="prefetch" href="/assets/js/45.811463a8.js"><link rel="prefetch" href="/assets/js/46.94aea5ef.js"><link rel="prefetch" href="/assets/js/47.2863ce6a.js"><link rel="prefetch" href="/assets/js/48.4239ef8f.js"><link rel="prefetch" href="/assets/js/49.7e48151d.js"><link rel="prefetch" href="/assets/js/5.c62fc94e.js"><link rel="prefetch" href="/assets/js/6.5bb0aa3d.js"><link rel="prefetch" href="/assets/js/7.8c724b93.js"><link rel="prefetch" href="/assets/js/8.d40cf774.js"><link rel="prefetch" href="/assets/js/9.a84cb03a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f3e8fa0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dajun</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML&amp;&amp;CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Interview/Vue/" class="sidebar-link">Vue 题集</a></li><li><a href="/Interview/Vue/yuanli.html" class="sidebar-link">Vue 原理相关</a></li><li><a href="/Interview/Vue/VirtualDom.html" class="sidebar-link">揭秘 Vue 中的 Virtual Dom</a></li><li><a href="/Interview/Vue/teng.html" class="active sidebar-link">腾面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="腾面试题"><a href="#腾面试题" aria-hidden="true" class="header-anchor">#</a> 腾面试题</h2> <p></p><div class="table-of-contents"><ul><li><a href="#腾面试题">腾面试题</a><ul><li><a href="#_1-项目流程">1.	项目流程</a></li><li><a href="#_2-移动端适配">2.	移动端适配</a></li><li><a href="#_3-你项目用过哪些es6">3.	你项目用过哪些es6</a></li><li><a href="#_4-什么是闭包">4.	什么是闭包</a></li><li><a href="#_5-原型链的理解">5.	原型链的理解</a></li><li><a href="#_6-你是怎么设置路由的">6.	你是怎么设置路由的</a></li><li><a href="#_7-keep-alive">7.	keep-alive</a></li><li><a href="#_8-跨域的解决办法">8.	跨域的解决办法</a></li><li><a href="#_9-git">9.	Git</a></li><li><a href="#_10-localstorage-sessionstroge-cookie的区别">10.	localstorage   sessionstroge  cookie的区别</a></li><li><a href="#_11-echarts-cavans，less的用法">11.	echarts  cavans，less的用法</a></li><li><a href="#_12-你对vuex的理解以及应用场景">12.	你对vuex的理解以及应用场景</a></li><li><a href="#_13-双向数据绑定原理">13.	双向数据绑定原理</a></li><li><a href="#_14-路由钩子你用过那些">14.	路由钩子你用过那些</a></li><li><a href="#_15-你用拦截器做些什么">15.	你用拦截器做些什么</a></li><li><a href="#_16-生命周期钩子">16.	生命周期钩子</a></li><li><a href="#_17-路由懒加载">17.	路由懒加载</a></li><li><a href="#_18-有没有做过webpacke的优化">18.	有没有做过webpacke的优化</a></li><li><a href="#_19-组件通讯的方法">19.	组件通讯的方法</a></li><li><a href="#_20-vue优化">20.	Vue优化</a></li><li><a href="#_21-什么是mvvm？">21.	什么是mvvm？</a></li><li><a href="#_22-为什么-vue-3-0-中使用-proxy-了？">22.	为什么 Vue 3.0 中使用 Proxy 了？</a></li><li><a href="#_23-项目中遇到的问题？">23.	项目中遇到的问题？</a></li><li><a href="#_24-virtual-dom">24.	Virtual DOM</a></li><li><a href="#_25-key">25.	Key</a></li><li><a href="#_26-vue-nexttick">26.	Vue.nextTick</a></li><li><a href="#_27-封装过的组件，有什么特别之处">27.	封装过的组件，有什么特别之处</a></li><li><a href="#_28-遇到的问题">28.	遇到的问题</a></li><li><a href="#_29-从url输入到页面展现到底发生什么？">29.	从URL输入到页面展现到底发生什么？</a></li></ul></li></ul></div><p></p> <h3 id="_1-项目流程"><a href="#_1-项目流程" aria-hidden="true" class="header-anchor">#</a> 1.	项目流程</h3> <ol><li>项目分析，用时评估</li> <li>选用哪种ui框架</li> <li>初始化项目</li> <li>分析页面结构，抽离公共组件</li> <li>编写页面，</li> <li>对接口</li> <li>全局功能补全，修复缺陷，优化代码</li> <li>部署测试环境</li> <li>测试提bug</li> <li>修复bug</li> <li>转正式网，复测</li></ol> <h3 id="_2-移动端适配"><a href="#_2-移动端适配" aria-hidden="true" class="header-anchor">#</a> 2.	移动端适配</h3> <p>设置不能手动缩放，显示比例为1，动态设置html 字体大小，再使用rem单位，使用
flex布局，和百分比</p> <h3 id="_3-你项目用过哪些es6"><a href="#_3-你项目用过哪些es6" aria-hidden="true" class="header-anchor">#</a> 3.	你项目用过哪些es6</h3> <ol><li>箭头函数</li> <li>定义方法可以不用 function 关键字</li> <li>字符串模板</li> <li>let 和 const 关键字</li> <li>Promises</li> <li>Object 的新 API</li> <li>import 和 export</li> <li>展开运算符(...)</li> <li>对象的解构赋值</li></ol> <h3 id="_4-什么是闭包"><a href="#_4-什么是闭包" aria-hidden="true" class="header-anchor">#</a> 4.	什么是闭包</h3> <p>当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。</p> <p>闭包的作用：
使用闭包可以访问函数中的变量。 可以使变量长期保存在内存中，生命周期比较长。 闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向 null。</p> <p>闭包主要有两个应用场景：</p> <ul><li>函数作为参数传递（见作用域部分例子）</li> <li>函数作为返回值</li></ul> <h3 id="_5-原型链的理解"><a href="#_5-原型链的理解" aria-hidden="true" class="header-anchor">#</a> 5.	原型链的理解</h3> <ul><li><p>原型：在 JavaScript 中原型是一个 prototype 对象，用于表示类型之间的关系。</p></li> <li><p>原型链：JavaScript 万物都是对象，对象和对象之间也有关系，并不是孤立存在的。
对象之间的继承关系，在 JavaScript 中是通过 prototype 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p></li> <li><p>所有的JS对象都有一个prototype属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></li></ul> <h3 id="_6-你是怎么设置路由的"><a href="#_6-你是怎么设置路由的" aria-hidden="true" class="header-anchor">#</a> 6.	你是怎么设置路由的</h3> <p>a)	不是很复杂的项目，就直接用一级路由，<br>
b)	有很多不同的模块，就用路由嵌套，路由拆分的写法，然后统一在index.js引入<br>
c)	定义路由的时候可以配置 meta 字段</p> <h3 id="_7-keep-alive"><a href="#_7-keep-alive" aria-hidden="true" class="header-anchor">#</a> 7.	keep-alive</h3> <p>&lt;keep-alive&gt; 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。<br>
使用&lt;keep-alive&gt;会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。</p> <p>a)	created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点。<br>
b)	destroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。</p> <h3 id="_8-跨域的解决办法"><a href="#_8-跨域的解决办法" aria-hidden="true" class="header-anchor">#</a> 8.	跨域的解决办法</h3> <p>a)	porxy 代理 定义和用法：proxy 代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。<br>
b)	使用cors,让后台接口请求头设置允许跨域访问。<br>
c)	jsonp 定义和用法：通过动态插入一个 script 标签。浏览器对 script 的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。 （无法post请求）</p> <h3 id="_9-git"><a href="#_9-git" aria-hidden="true" class="header-anchor">#</a> 9.	Git</h3> <p>git  pull
git clone<br>
git add .<br>
git commit –m  ‘描述’<br>
git push</p> <h3 id="_10-localstorage-sessionstroge-cookie的区别"><a href="#_10-localstorage-sessionstroge-cookie的区别" aria-hidden="true" class="header-anchor">#</a> 10.	localstorage   sessionstroge  cookie的区别</h3> <ol><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据 - 通常经过加密</li> <li>cookie数据始终在同源的http请求中携带，即使不需要，也会在浏览器和服务器间来回传递。</li> <li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
<em><strong>存储大小：</strong></em></li></ol> <ul><li>cookie数据大小不能超过4K</li> <li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
<em><strong>有效时间：</strong></em></li> <li>localStorage:存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li> <li>sessionStorage:数据在当前浏览器窗口关闭后自动删除</li> <li>cookie：设置的cookie过期时间前一直有效，即使窗口和浏览器关闭</li></ul> <h3 id="_11-echarts-cavans，less的用法"><a href="#_11-echarts-cavans，less的用法" aria-hidden="true" class="header-anchor">#</a> 11.	echarts  cavans，less的用法</h3> <p>echart</p> <ol><li>通过 npm 获取 echarts，npm install echarts --save，详见“在 webpack 中使用 echarts”</li> <li>cdn 引入，你可以在 cdnjs，npmcdn 或者国内的 bootcdn 上找到 ECharts 的最新版本</li> <li></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 基于准备好的dom，初始化echarts实例</span>
        <span class="token keyword">var</span> myChart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">;</span>
vue<span class="token operator">-</span>echarts
</code></pre></div><p>如果你的需求是定制化比较少的，基本上绑定数据然后展示就行了，或者你对echarts还不是很熟悉的，那么vue-echarts是一个不错的选择；</p> <p>canvas</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> c<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myCanvas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> cxt<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">&quot;2d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cxt<span class="token punctuation">.</span>fillStyle<span class="token operator">=</span><span class="token string">&quot;#FF0000&quot;</span><span class="token punctuation">;</span>
cxt<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cxt<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cxt<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cxt<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>less</p> <ul><li>第一步：先装 css-loader、node-loader、sass-loader 等加载器模块</li> <li>第二步：在 build 目录找到 webpack.base.config.js，在那个 extends 属性中加一个拓展.scss</li> <li>第三步：在同一个文件，配置一个 module 属性</li> <li>第四步：然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss” 特性:</li> <li>可以用变量，例如（$变量名称=值）；</li> <li>可以用混合器，例如（）</li> <li>可以嵌套</li></ul> <h3 id="_12-你对vuex的理解以及应用场景"><a href="#_12-你对vuex的理解以及应用场景" aria-hidden="true" class="header-anchor">#</a> 12.	你对vuex的理解以及应用场景</h3> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>
a)	涉及到非父子关系的组件，例如兄弟关系、祖孙关系，甚至更远的关系；<br>
b)	他们之间如果有数据交互，那么应该使用Vuex来实现；<br>
c)	如果页面复杂度比较低的话，也可以考虑使用 global-event-bus 来实现；<br>
d)	如果只是父子关系的组件数据交互，那么应该考虑使用props进行单向传递；<br>
e)	如果涉及到子组件向父组件的数据传递，那么应该考虑使用 $emit 和 $on；</p> <p>优点，假如你需要 数据 和 组件 分离，分别处理，那么使用 Vuex 是非常合适的。</p> <h3 id="_13-双向数据绑定原理"><a href="#_13-双向数据绑定原理" aria-hidden="true" class="header-anchor">#</a> 13.	双向数据绑定原理</h3> <p>Vue 采用 数据劫持 结合 发布者-订阅者 模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter 以及 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p> <ol><li>第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li> <li>第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新数据。</li> <li>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情有：</li></ol> <ul><li>在自身实例化时往属性订阅器（dep）里面添加自己。</li> <li>自身必须有一个 update() 方法</li> <li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</li></ul> <ol start="4"><li>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的桥梁，达到数据变化 -&gt; 视图更新；视图交互变化（input） -&gt; 数据 model 变更的双向绑定效果。</li></ol> <h3 id="_14-路由钩子你用过那些"><a href="#_14-路由钩子你用过那些" aria-hidden="true" class="header-anchor">#</a> 14.	路由钩子你用过那些</h3> <p>三类钩子：</p> <ol><li>全局钩子
beforeEach</li> <li>某个路由独享的钩子
beforeEnter</li> <li>组件内钩子</li></ol> <ul><li>beforeRouteEnter  在渲染该组件的对应路由被 confirm 前调用，不能获取组件实例 this，因为当守卫执行前，组件实例还没被创建</li> <li>beforeRouteUpdate  在当前路由改变，但是该组件被复用时调用</li> <li>beforeRouteLeave 导航离开该组件的对应路由时调用</li></ul> <p>主要三个参数</p> <ul><li>to: Route: 即将要进入的路由对象</li> <li>from: Route: 当前导航正要离开的路由</li> <li>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</li></ul> <h3 id="_15-你用拦截器做些什么"><a href="#_15-你用拦截器做些什么" aria-hidden="true" class="header-anchor">#</a> 15.	你用拦截器做些什么</h3> <ol><li>请求拦截器<br>
修改传参，加密参数</li> <li>响应拦截器<br>
统一处理错误请求，响应码</li></ol> <h3 id="_16-生命周期钩子"><a href="#_16-生命周期钩子" aria-hidden="true" class="header-anchor">#</a> 16.	生命周期钩子</h3> <table><thead><tr><th>生命周期钩子</th> <th>详细</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</td></tr> <tr><td>created</td> <td>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 render 函数首次被调用。</td></tr> <tr><td>mounted</td> <td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</td></tr> <tr><td>beforeUpdate</td> <td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</td></tr> <tr><td>updated</td> <td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</td></tr> <tr><td>activated</td> <td>keep-alive 组件激活时调用。</td></tr> <tr><td>deactivated</td> <td>keep-alive 组件停用时调用。</td></tr> <tr><td>beforeDestroy</td> <td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr> <tr><td>destroyed</td> <td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</td></tr></tbody></table> <h3 id="_17-路由懒加载"><a href="#_17-路由懒加载" aria-hidden="true" class="header-anchor">#</a> 17.	路由懒加载</h3> <ol><li>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</li> <li>第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：<br>
结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./Foo.vue'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_18-有没有做过webpacke的优化"><a href="#_18-有没有做过webpacke的优化" aria-hidden="true" class="header-anchor">#</a> 18.	有没有做过webpacke的优化</h3> <p>编译优化</p> <ol><li>优化Loader配置</li></ol> <ul><li>resolve.alias（文件引用@）</li> <li>resolve.noParse（过滤分析jq）</li></ul> <ol><li>减少冗余代码，ES6代码转换成ES5代码时，通常需要一些由ES5编写的辅助函数来完成新语法的实现，</li> <li>使用ParallelUglifyPlugin多进程压缩代码文件</li> <li>提取公共代码</li> <li>使用Tree Shaking剔除JS死代码</li> <li>使用DllPlugin减少基础模块编译次数，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。</li></ol> <h3 id="_19-组件通讯的方法"><a href="#_19-组件通讯的方法" aria-hidden="true" class="header-anchor">#</a> 19.	组件通讯的方法</h3> <ol><li>props</li> <li>$emit</li> <li>provide和inject</li> <li>$parent和$children</li> <li>Bus中间通信</li> <li>Vuex</li> <li>Cookie</li></ol> <h3 id="_20-vue优化"><a href="#_20-vue优化" aria-hidden="true" class="header-anchor">#</a> 20.	Vue优化</h3> <p><em><strong>一、代码层面的优化</strong></em></p> <ol><li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch 区分使用场景</li> <li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li> <li>长列表性能优化，展示型数据用Object.freeze</li> <li>事件的销毁 Vue 组件销毁时</li> <li>图片资源懒加载</li> <li>路由懒加载</li> <li>第三方插件的按需引入<br> <em><strong>二、Webpack 层面的优化</strong></em></li> <li>Webpack 对图片进行压缩,对小于 limit 的图片转化为 base64 格式所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片</li> <li>减少 ES6 转为 ES5 的冗余代码
Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数  安装 babel-plugin-transform-runtim</li> <li>删除死代码（Tree Shaking）<br> <em><strong>三、基础的 Web 技术优化</strong></em></li> <li>开启 gzip 压缩</li> <li>缓存，打包时候，文件名用chuckname，</li> <li>CDN 的使用</li></ol> <h3 id="_21-什么是mvvm？"><a href="#_21-什么是mvvm？" aria-hidden="true" class="header-anchor">#</a> 21.	什么是mvvm？</h3> <p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互时双向的，因此 View 数据会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。<br>
ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需要关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</p> <h3 id="_22-为什么-vue-3-0-中使用-proxy-了？"><a href="#_22-为什么-vue-3-0-中使用-proxy-了？" aria-hidden="true" class="header-anchor">#</a> 22.	为什么 Vue 3.0 中使用 Proxy 了？</h3> <ol><li>Vue 中使用 Object.defineProperty 进行双向数据绑定时，告知使用者是可以监听数组的，但是只是监听了数组的 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 这八种方法，其他数组的属性检测不到。</li> <li>Object.defineProperty 只能劫持对象的属性，因此对每个对象的属性进行遍历时，如果属性值也是对象需要深度遍历，那么就比较麻烦了，所以在比较 Proxy 能完整劫持对象的对比下，选择 Proxy。</li> <li>为什么 Proxy 在 Vue 2.0 编写的时候出来了，尤大却没有用上去？因为当时 es6 环境不够成熟，兼容性不好，尤其是这个属性无法用 polyfill 来兼容。（polyfill 是一个 js 库，专门用来处理 js 的兼容性问题-js 修补器）</li></ol> <h3 id="_23-项目中遇到的问题？"><a href="#_23-项目中遇到的问题？" aria-hidden="true" class="header-anchor">#</a> 23.	项目中遇到的问题？</h3> <h3 id="_24-virtual-dom"><a href="#_24-virtual-dom" aria-hidden="true" class="header-anchor">#</a> 24.	Virtual DOM</h3> <p>Vue 在 render 中 createElement 的时候，并不是产生真实的 DOM 元素，实际上 createElement 描述为 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点。</p> <h3 id="_25-key"><a href="#_25-key" aria-hidden="true" class="header-anchor">#</a> 25.	Key</h3> <p>key 的作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的</p> <h3 id="_26-vue-nexttick"><a href="#_26-vue-nexttick" aria-hidden="true" class="header-anchor">#</a> 26.	Vue.nextTick</h3> <p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <h3 id="_27-封装过的组件，有什么特别之处"><a href="#_27-封装过的组件，有什么特别之处" aria-hidden="true" class="header-anchor">#</a> 27.	封装过的组件，有什么特别之处</h3> <h3 id="_28-遇到的问题"><a href="#_28-遇到的问题" aria-hidden="true" class="header-anchor">#</a> 28.	遇到的问题</h3> <p>a)	秒杀型页面，
b)	白屏时间过长、</p> <h3 id="_29-从url输入到页面展现到底发生什么？"><a href="#_29-从url输入到页面展现到底发生什么？" aria-hidden="true" class="header-anchor">#</a> 29.	从URL输入到页面展现到底发生什么？</h3> <ol><li><p>DNS 解析:将域名解析成 IP 地址</p></li> <li><p>TCP 连接：TCP 三次握手</p></li> <li><p>发送 HTTP 请求</p></li> <li><p>服务器处理请求并返回 HTTP 报文</p></li> <li><p>浏览器解析渲染页面
i.	根据 HTML 解析出 DOM 树<br>
ii.	根据 CSS 解析生成 CSS 规则树<br>
iii.	结合 DOM 树和 CSS 规则树，生成渲染树<br>
iv.	根据渲染树计算每一个节点的信息<br>
v.	根据计算好的信息绘制页面</p></li> <li><p>断开连接：TCP 四次挥手</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Interview/Vue/VirtualDom.html" class="prev">
          揭秘 Vue 中的 Virtual Dom
        </a></span> <span class="next"><a href="/Interview/ES6/">
          ES6 题集 1
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c18ba2b.js" defer></script><script src="/assets/js/2.2d7f6841.js" defer></script><script src="/assets/js/34.a08208a6.js" defer></script>
  </body>
</html>
