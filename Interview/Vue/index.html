<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 题集 | Dajun</title>
    <meta name="description" content="笔记">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.7f3e8fa0.css" as="style"><link rel="preload" href="/assets/js/app.3c18ba2b.js" as="script"><link rel="preload" href="/assets/js/2.2d7f6841.js" as="script"><link rel="preload" href="/assets/js/32.baa6441c.js" as="script"><link rel="prefetch" href="/assets/js/10.4e623ea8.js"><link rel="prefetch" href="/assets/js/11.1b2a7179.js"><link rel="prefetch" href="/assets/js/12.8062ade3.js"><link rel="prefetch" href="/assets/js/13.edc49012.js"><link rel="prefetch" href="/assets/js/14.e84ee3f4.js"><link rel="prefetch" href="/assets/js/15.e8d4142b.js"><link rel="prefetch" href="/assets/js/16.40a39847.js"><link rel="prefetch" href="/assets/js/17.1c075161.js"><link rel="prefetch" href="/assets/js/18.34b4e583.js"><link rel="prefetch" href="/assets/js/19.7f97ee03.js"><link rel="prefetch" href="/assets/js/20.aabac5c0.js"><link rel="prefetch" href="/assets/js/21.d261013f.js"><link rel="prefetch" href="/assets/js/22.b7560755.js"><link rel="prefetch" href="/assets/js/23.eb76ccea.js"><link rel="prefetch" href="/assets/js/24.6d592b30.js"><link rel="prefetch" href="/assets/js/25.b30f5339.js"><link rel="prefetch" href="/assets/js/26.8efe380d.js"><link rel="prefetch" href="/assets/js/27.94f1d5b7.js"><link rel="prefetch" href="/assets/js/28.4d86e4cc.js"><link rel="prefetch" href="/assets/js/29.2b342c8d.js"><link rel="prefetch" href="/assets/js/3.976ff7bf.js"><link rel="prefetch" href="/assets/js/30.68cd5081.js"><link rel="prefetch" href="/assets/js/31.fef0ba54.js"><link rel="prefetch" href="/assets/js/33.9c22ff1b.js"><link rel="prefetch" href="/assets/js/34.a08208a6.js"><link rel="prefetch" href="/assets/js/35.f0d94ae9.js"><link rel="prefetch" href="/assets/js/36.8f885fc3.js"><link rel="prefetch" href="/assets/js/37.7fd3e68c.js"><link rel="prefetch" href="/assets/js/38.bd73a7cf.js"><link rel="prefetch" href="/assets/js/39.2dca5b84.js"><link rel="prefetch" href="/assets/js/4.ab25bdf6.js"><link rel="prefetch" href="/assets/js/40.e324d414.js"><link rel="prefetch" href="/assets/js/41.32b91a1c.js"><link rel="prefetch" href="/assets/js/42.fee64b88.js"><link rel="prefetch" href="/assets/js/43.fc4fcb6c.js"><link rel="prefetch" href="/assets/js/44.3aeab9ce.js"><link rel="prefetch" href="/assets/js/45.811463a8.js"><link rel="prefetch" href="/assets/js/46.94aea5ef.js"><link rel="prefetch" href="/assets/js/47.2863ce6a.js"><link rel="prefetch" href="/assets/js/48.4239ef8f.js"><link rel="prefetch" href="/assets/js/49.7e48151d.js"><link rel="prefetch" href="/assets/js/5.c62fc94e.js"><link rel="prefetch" href="/assets/js/6.5bb0aa3d.js"><link rel="prefetch" href="/assets/js/7.8c724b93.js"><link rel="prefetch" href="/assets/js/8.d40cf774.js"><link rel="prefetch" href="/assets/js/9.a84cb03a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f3e8fa0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dajun</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML&amp;&amp;CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Interview/Vue/" class="active sidebar-link">Vue 题集</a></li><li><a href="/Interview/Vue/yuanli.html" class="sidebar-link">Vue 原理相关</a></li><li><a href="/Interview/Vue/VirtualDom.html" class="sidebar-link">揭秘 Vue 中的 Virtual Dom</a></li><li><a href="/Interview/Vue/teng.html" class="sidebar-link">腾面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-题集"><a href="#vue-题集" aria-hidden="true" class="header-anchor">#</a> Vue 题集</h2> <p></p><div class="table-of-contents"><ul><li><a href="#vue-题集">Vue 题集</a><ul><li><a href="#_1-什么是-mvvm？">1.什么是 MVVM？</a></li><li><a href="#_2-mvvm-和-mvc-区别？它和其它框架（jquery）的区别是什么？哪些场景适合？">2.mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</a></li><li><a href="#_3-vue-的优点是什么？">3.vue 的优点是什么？</a></li><li><a href="#_4-vuex-面试相关">4.vuex 面试相关</a></li><li><a href="#_5-指令-v-el-的作用是什么">5.指令 v-el 的作用是什么?</a></li><li><a href="#_6-请列举出-3-个-vue-中常用的生命周期钩子函数">6.请列举出 3 个 Vue 中常用的生命周期钩子函数</a></li><li><a href="#_7-active-class-是哪个组件的属性？">7.active-class 是哪个组件的属性？</a></li><li><a href="#_8-vue-router-有哪几种导航钩子？">8.vue-router 有哪几种导航钩子？</a></li><li><a href="#_9-生命周期相关面试题">9.生命周期相关面试题</a></li><li><a href="#_10-vue-loader-是什么？使用它的用途有哪些？">10.vue-loader 是什么？使用它的用途有哪些？</a></li><li><a href="#_11-scss-是什么？在-vue-cli-中的安装使用步骤是？有哪几大特性？">11.scss 是什么？在 vue.cli 中的安装使用步骤是？有哪几大特性？</a></li><li><a href="#_12-为什么使用-key？">12.为什么使用 key？</a></li><li><a href="#_13-为什么避免-v-if-和-v-for-用在一起">13.为什么避免 v-if 和 v-for 用在一起</a></li><li><a href="#_14-vnode-是什么？虚拟-dom-是什么？">14.VNode 是什么？虚拟 DOM 是什么？</a></li><li><a href="#_15-实现-vue-ssr">15.实现 Vue SSR</a></li><li><a href="#_2-“什么阶段才能访问-dom？”">2. “什么阶段才能访问 DOM？”</a></li><li><a href="#_3-“谈谈你对-vue-的生命周期的理解”">3. “谈谈你对 Vue 的生命周期的理解”</a></li><li><a href="#_4-“vue-router-路由模式有几种？”">4. “Vue-router 路由模式有几种？”</a></li><li><a href="#_5-“谈谈你对-keep-alive-的了解？”">5. “谈谈你对 keep-alive 的了解？”</a></li></ul></li></ul></div><p></p> <h3 id="_1-什么是-mvvm？"><a href="#_1-什么是-mvvm？" aria-hidden="true" class="header-anchor">#</a> 1.什么是 MVVM？</h3> <ul><li><p>MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p></li> <li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p></li> <li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p></li></ul> <h3 id="_2-mvvm-和-mvc-区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#_2-mvvm-和-mvc-区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" aria-hidden="true" class="header-anchor">#</a> 2.mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h3> <p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。</p> <p>场景：数据操作比较多的场景，更加便捷</p> <h3 id="_3-vue-的优点是什么？"><a href="#_3-vue-的优点是什么？" aria-hidden="true" class="header-anchor">#</a> 3.vue 的优点是什么？</h3> <ul><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的&quot;View&quot;上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li> <li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li> <li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li> <li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul> <h3 id="_4-vuex-面试相关"><a href="#_4-vuex-面试相关" aria-hidden="true" class="header-anchor">#</a> 4.vuex 面试相关</h3> <p>（1）vuex 是什么？怎么使用？哪种功能场景使用它？
vue 框架中状态管理。在 main.js 引入 store，注入。新建一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
（2）vuex 有哪几种属性？
有五种，分别是 State、 Getter、Mutation 、Action、 Module</p> <ul><li>vuex 的 State 特性
A、Vuex 就是一个仓库，仓库里面放了很多对象。其中 state 就是数据源存放地，对应于一般 Vue 对象里面的 data</li></ul> <p>B、state 里面存放的数据是响应式的，Vue 组件从 store 中读取数据，若是 store 中的数据发生改变，依赖这个数据的组件也会发生更新</p> <p>C、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p> <ul><li>vuex 的 Getter 特性
A、getters 可以对 State 进行计算操作，它就是 Store 的计算属性</li></ul> <p>B、 虽然在组件内也可以做计算属性，但是 getters 可以在多组件之间复用</p> <p>C、 如果一个状态只在一个组件内使用，是可以不用 getters</p> <ul><li>vuex 的 Mutation 特性
Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。
（3）不用 Vuex 会带来什么问题？</li> <li>可维护性会下降，想修改数据要维护三个地方；</li> <li>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</li> <li>增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。</li></ul> <h3 id="_5-指令-v-el-的作用是什么"><a href="#_5-指令-v-el-的作用是什么" aria-hidden="true" class="header-anchor">#</a> 5.指令 v-el 的作用是什么?</h3> <p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p> <h3 id="_6-请列举出-3-个-vue-中常用的生命周期钩子函数"><a href="#_6-请列举出-3-个-vue-中常用的生命周期钩子函数" aria-hidden="true" class="header-anchor">#</a> 6.请列举出 3 个 Vue 中常用的生命周期钩子函数</h3> <ul><li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event 事件回调. 然而, 挂载阶段还没有开始, $el 属性目前还不可见</li> <li>mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li> <li>activated: keep-alive 组件激活时调用</li></ul> <h3 id="_7-active-class-是哪个组件的属性？"><a href="#_7-active-class-是哪个组件的属性？" aria-hidden="true" class="header-anchor">#</a> 7.active-class 是哪个组件的属性？</h3> <p>vue-router 模块的 router-link 组件。</p> <h3 id="_8-vue-router-有哪几种导航钩子？"><a href="#_8-vue-router-有哪几种导航钩子？" aria-hidden="true" class="header-anchor">#</a> 8.vue-router 有哪几种导航钩子？</h3> <p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子；
第三种：单独路由独享组件</p> <h3 id="_9-生命周期相关面试题"><a href="#_9-生命周期相关面试题" aria-hidden="true" class="header-anchor">#</a> 9.生命周期相关面试题</h3> <p>总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p> <ul><li>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，el 还没有。</li> <li>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</li> <li>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li> <li>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在
（1）、什么是 vue 生命周期</li></ul> <p>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p>（2）、vue 生命周期的作用是什么</p> <p>答：它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。</p> <p>（3）、vue 生命周期总共有几个阶段</p> <p>答：可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p> <p>（4）、第一次页面加载会触发哪几个钩子</p> <p>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p> <p>（5）、DOM 渲染在 哪个周期中就已经完成</p> <p>答：DOM 渲染在 mounted 中就已经完成了。</p> <p>（6）、简单描述每个周期具体适合哪些场景</p> <p>答：生命周期钩子的一些使用方法：</p> <ul><li>beforecreate : 可以在这加个 loading 事件，在加载实例时触发</li> <li>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用</li> <li>mounted : 挂载元素，获取到 DOM 节点</li> <li>updated : 如果对数据统一处理，在这里写上相应函数</li> <li>beforeDestroy : 可以做一个确认停止事件的确认框</li> <li>nextTick : 更新数据后立即操作 dom</li></ul> <h3 id="_10-vue-loader-是什么？使用它的用途有哪些？"><a href="#_10-vue-loader-是什么？使用它的用途有哪些？" aria-hidden="true" class="header-anchor">#</a> 10.vue-loader 是什么？使用它的用途有哪些？</h3> <p>解析.vue 文件的一个加载器。
用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p> <h3 id="_11-scss-是什么？在-vue-cli-中的安装使用步骤是？有哪几大特性？"><a href="#_11-scss-是什么？在-vue-cli-中的安装使用步骤是？有哪几大特性？" aria-hidden="true" class="header-anchor">#</a> 11.scss 是什么？在 vue.cli 中的安装使用步骤是？有哪几大特性？</h3> <p>答：css 的预编译。
使用步骤：</p> <ul><li>第一步：先装 css-loader、node-loader、sass-loader 等加载器模块</li> <li>第二步：在 build 目录找到 webpack.base.config.js，在那个 extends 属性中加一个拓展.scss</li> <li>第三步：在同一个文件，配置一个 module 属性</li> <li>第四步：然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss”
特性:</li> <li>可以用变量，例如（$变量名称=值）；</li> <li>可以用混合器，例如（）</li> <li>可以嵌套</li></ul> <h3 id="_12-为什么使用-key？"><a href="#_12-为什么使用-key？" aria-hidden="true" class="header-anchor">#</a> 12.为什么使用 key？</h3> <p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p> <h3 id="_13-为什么避免-v-if-和-v-for-用在一起"><a href="#_13-为什么避免-v-if-和-v-for-用在一起" aria-hidden="true" class="header-anchor">#</a> 13.为什么避免 v-if 和 v-for 用在一起</h3> <p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p> <h3 id="_14-vnode-是什么？虚拟-dom-是什么？"><a href="#_14-vnode-是什么？虚拟-dom-是什么？" aria-hidden="true" class="header-anchor">#</a> 14.VNode 是什么？虚拟 DOM 是什么？</h3> <p>Vue 在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</p> <h3 id="_15-实现-vue-ssr"><a href="#_15-实现-vue-ssr" aria-hidden="true" class="header-anchor">#</a> 15.实现 Vue SSR</h3> <p>其基本实现原理：</p> <ul><li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。</li> <li>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。</li> <li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li> <li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为「 客户端激活 」。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.<strong>INITIAL_STATE</strong> 发送到客户端。
Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。
纯客户端输出过程有一个 complier 过程（「 下题 」中有一个简单描述），主要作用是将 template 转化成 render 字符串 。
Vue SSR 需要做的事多点（输出完整 HTML），除了 complier -&gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。
和其他模板引擎（ejs, jade 等）最终要实现的目的是一样的，性能上可能要差点。</li></ul> <p>###　 1. “ newVue()做了什么？”
new 关键字代表实例化一个对象, 而 Vue 实际上是一个类, 源码位置是 /src/core/instance/index.js。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Vue is a constructor and should be called with the `new` keyword&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着我们跳转追踪至 this._init()，即 Vue.prototype._init,位于 srccoreinstanceinit.js 在 _init()方法的内部有一系列 init* 的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token punctuation">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token comment">// ...忽略，从第45行看起</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// expose real self</span>
  vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> <span class="token function">vminitLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;beforeCreate&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// resolve injections before data/props</span>
  <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">nitProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// resolve provide after data/props</span>
  <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;created&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...忽略</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>1.1 这里我们概述一遍：</p> <ul><li><p>initProxy，作用域代理，拦截组件内访问其它组件的数据。</p></li> <li><p>initLifecycle, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如： $children、 $refs、 _isMounted 等。</p></li> <li><p>initEvents，用来存放除 @hook:生命周期钩子名称=&quot;绑定的函数&quot;事件的对象。如： $on、 $emit 等。</p></li> <li><p>initRender，用于初始化 $slots、 $attrs、 $listeners</p></li> <li><p>initInjections，初始化 inject，一般用于更深层次的组件通信，相当于加强版子组件的 props。用于组件库开发较多。</p></li></ul> <p>只要在上一层级的声明的 provide，那么下一层级无论多深都能够通过 inject 来访问到 provide 的数据。这么做也是有明显的缺点：在任意层级都能访问，导致数据追踪比较困难，不知道是哪一个层级声明了这个或者不知道哪一层级或若干个层级使用。</p> <ul><li><p>initState，是很多选项初始化的汇总，包括： props、methods、data、computed 和 watch 等。</p></li> <li><p>initProvide，初始化 provide。</p></li> <li><p>vm.$mount，挂载实例。</p></li></ul> <h3 id="_2-“什么阶段才能访问-dom？”"><a href="#_2-“什么阶段才能访问-dom？”" aria-hidden="true" class="header-anchor">#</a> 2. “什么阶段才能访问 DOM？”</h3> <p>这个回答可以从 beforeCreate 以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;beforeCreate&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化 inject</span>

<span class="token comment">// 初始化 props、methods、data、computed 和 watch</span>

<span class="token comment">// 初始化 provide</span>

<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;created&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 挂载实例 vm.$mount(vm.$options.el)</span>
</code></pre></div><p>所以当面试官问你：</p> <p>beforeCreate 以及 created 调用时，哪些数据能用与否？</p> <p>什么阶段才能访问 DOM？</p> <p>为什么 created 之后才挂载实例？</p> <h3 id="_3-“谈谈你对-vue-的生命周期的理解”"><a href="#_3-“谈谈你对-vue-的生命周期的理解”" aria-hidden="true" class="header-anchor">#</a> 3. “谈谈你对 Vue 的生命周期的理解”</h3> <p>常规回答这里就不说了，来稍微深入点的：</p> <p>created/mounted/updated/destroyed，以及对应的 before 钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁。</p> <p>Vue 源码中定义了一个 mergeHook 函数来遍历一个常量数组 LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// v2.6.10 最新版</span>

<span class="token keyword">var</span> <span class="token constant">LIFECYCLE_HOOKS</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;beforeCreate&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;created&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeMount&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;mounted&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeUpdate&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;updated&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeDestroy&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;destroyed&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;activated&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;deactivated&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;errorCaptured&quot;</span><span class="token punctuation">,</span>
  <span class="token comment">// v2.6+</span>
  <span class="token string">&quot;serverPrefetch&quot;</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>于是，你可以答多 activated&amp;deactivated（keep-alive 组件激活/停用）、errorCaptured（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p> <h3 id="_4-“vue-router-路由模式有几种？”"><a href="#_4-“vue-router-路由模式有几种？”" aria-hidden="true" class="header-anchor">#</a> 4. “Vue-router 路由模式有几种？”</h3> <p>三种 &quot;hash&quot;|&quot;history&quot;|&quot;abstract&quot;，一般人只知道两种 &quot;hash&quot;|&quot;history&quot;。</p> <p>这里贴出源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">&quot;history&quot;</span><span class="token punctuation">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">break</span><span class="token punctuation">;</span>

  <span class="token keyword">case</span> <span class="token string">&quot;hash&quot;</span><span class="token punctuation">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">break</span><span class="token punctuation">;</span>

  <span class="token keyword">case</span> <span class="token string">&quot;abstract&quot;</span><span class="token punctuation">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">break</span><span class="token punctuation">;</span>

  <span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&quot;production&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="mode"><a href="#mode" aria-hidden="true" class="header-anchor">#</a> mode</h4> <p>类型: string</p> <p>默认值: &quot;hash&quot;(浏览器环境)|&quot;abstract&quot;(Node.js 环境)</p> <p>可选值: &quot;hash&quot;|&quot;history&quot;|&quot;abstract&quot; 配置路由模式:</p> <p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5HistoryApi 的浏览器。</p> <p>history: 依赖 HTML5History API 和服务器配置。查看 HTML5History 模式。</p> <p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p> <h3 id="_5-“谈谈你对-keep-alive-的了解？”"><a href="#_5-“谈谈你对-keep-alive-的了解？”" aria-hidden="true" class="header-anchor">#</a> 5. “谈谈你对 keep-alive 的了解？”</h3> <p>先贴一个常规回答：</p> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 在 vue 2.1.0 版本之后，keep-alive 新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于 include) 。</p> <p>然后你可以开始骚了：</p> <p>keep-alive是 Vue 源码中实现的一个全局抽象组件，通过自定义 render 函数并且利用了插槽来实现数据缓存和更新。它的定义在 src/core/components/keep-alive.js 中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
name<span class="token punctuation">:</span><span class="token string">'keep-alive'</span><span class="token punctuation">,</span>
abstract<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的抽象组件是通过定义 abstract 选项来声明的。抽象组件不渲染真实 DOM，且不会出现在父子关系的路径上（ initLifecycle 会忽略抽象组件），相关代码片段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// abstract 即 `ptions.abstract`</span>

  <span class="token comment">// while 循环查找第一个非抽象的父组件</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Interview/JavaScript/kaodian.html" class="prev">
          Javascript面试核心考点
        </a></span> <span class="next"><a href="/Interview/Vue/yuanli.html">
          Vue 原理相关
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c18ba2b.js" defer></script><script src="/assets/js/2.2d7f6841.js" defer></script><script src="/assets/js/32.baa6441c.js" defer></script>
  </body>
</html>
