<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 题集 2 | Dajun</title>
    <meta name="description" content="笔记">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.7f3e8fa0.css" as="style"><link rel="preload" href="/assets/js/app.3c18ba2b.js" as="script"><link rel="preload" href="/assets/js/2.2d7f6841.js" as="script"><link rel="preload" href="/assets/js/28.4d86e4cc.js" as="script"><link rel="prefetch" href="/assets/js/10.4e623ea8.js"><link rel="prefetch" href="/assets/js/11.1b2a7179.js"><link rel="prefetch" href="/assets/js/12.8062ade3.js"><link rel="prefetch" href="/assets/js/13.edc49012.js"><link rel="prefetch" href="/assets/js/14.e84ee3f4.js"><link rel="prefetch" href="/assets/js/15.e8d4142b.js"><link rel="prefetch" href="/assets/js/16.40a39847.js"><link rel="prefetch" href="/assets/js/17.1c075161.js"><link rel="prefetch" href="/assets/js/18.34b4e583.js"><link rel="prefetch" href="/assets/js/19.7f97ee03.js"><link rel="prefetch" href="/assets/js/20.aabac5c0.js"><link rel="prefetch" href="/assets/js/21.d261013f.js"><link rel="prefetch" href="/assets/js/22.b7560755.js"><link rel="prefetch" href="/assets/js/23.eb76ccea.js"><link rel="prefetch" href="/assets/js/24.6d592b30.js"><link rel="prefetch" href="/assets/js/25.b30f5339.js"><link rel="prefetch" href="/assets/js/26.8efe380d.js"><link rel="prefetch" href="/assets/js/27.94f1d5b7.js"><link rel="prefetch" href="/assets/js/29.2b342c8d.js"><link rel="prefetch" href="/assets/js/3.976ff7bf.js"><link rel="prefetch" href="/assets/js/30.68cd5081.js"><link rel="prefetch" href="/assets/js/31.fef0ba54.js"><link rel="prefetch" href="/assets/js/32.baa6441c.js"><link rel="prefetch" href="/assets/js/33.9c22ff1b.js"><link rel="prefetch" href="/assets/js/34.a08208a6.js"><link rel="prefetch" href="/assets/js/35.f0d94ae9.js"><link rel="prefetch" href="/assets/js/36.8f885fc3.js"><link rel="prefetch" href="/assets/js/37.7fd3e68c.js"><link rel="prefetch" href="/assets/js/38.bd73a7cf.js"><link rel="prefetch" href="/assets/js/39.2dca5b84.js"><link rel="prefetch" href="/assets/js/4.ab25bdf6.js"><link rel="prefetch" href="/assets/js/40.e324d414.js"><link rel="prefetch" href="/assets/js/41.32b91a1c.js"><link rel="prefetch" href="/assets/js/42.fee64b88.js"><link rel="prefetch" href="/assets/js/43.fc4fcb6c.js"><link rel="prefetch" href="/assets/js/44.3aeab9ce.js"><link rel="prefetch" href="/assets/js/45.811463a8.js"><link rel="prefetch" href="/assets/js/46.94aea5ef.js"><link rel="prefetch" href="/assets/js/47.2863ce6a.js"><link rel="prefetch" href="/assets/js/48.4239ef8f.js"><link rel="prefetch" href="/assets/js/49.7e48151d.js"><link rel="prefetch" href="/assets/js/5.c62fc94e.js"><link rel="prefetch" href="/assets/js/6.5bb0aa3d.js"><link rel="prefetch" href="/assets/js/7.8c724b93.js"><link rel="prefetch" href="/assets/js/8.d40cf774.js"><link rel="prefetch" href="/assets/js/9.a84cb03a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f3e8fa0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dajun</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Notes/" class="nav-link">笔记</a></div><div class="nav-item"><a href="/Summary/" class="nav-link">总结</a></div><div class="nav-item"><a href="/Reprint/" class="nav-link">转载</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML&amp;&amp;CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Interview/JavaScript/" class="sidebar-link">Javascript 题集 1</a></li><li><a href="/Interview/JavaScript/index3.html" class="active sidebar-link">js 题集 2</a></li><li><a href="/Interview/JavaScript/index2.html" class="sidebar-link">javascript 相关程序计算题</a></li><li><a href="/Interview/JavaScript/xuanzeti.html" class="sidebar-link">JavaScript 进阶问题</a></li><li><a href="/Interview/JavaScript/kaodian.html" class="sidebar-link">Javascript面试核心考点</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js-题集-2"><a href="#js-题集-2" aria-hidden="true" class="header-anchor">#</a> js 题集 2</h2> <p></p><div class="table-of-contents"><ul><li><a href="#js-题集-2">js 题集 2</a><ul><li><a href="#_1-this-对象的理解">1. this 对象的理解</a></li><li><a href="#_2-解释下-js-中-this-是怎么工作的">2. 解释下 js 中 this 是怎么工作的?</a></li><li><a href="#_3-eval-是做什么的？">3. eval 是做什么的？</a></li><li><a href="#_4-new-操作符具体干了什么呢">4. new 操作符具体干了什么呢?</a></li><li><a href="#_5-你有哪些性能优化的方法？">5. 你有哪些性能优化的方法？</a></li><li><a href="#_6-哪些常见操作会造成内存泄漏？">6. 哪些常见操作会造成内存泄漏？</a></li><li><a href="#_7-线程与进程的区别">7. 线程与进程的区别</a></li><li><a href="#_8-什么是闭包？">8. 什么是闭包？</a></li><li><a href="#_9-在-javascript-中什么是伪数组？如何将伪数组转化为标准数组？">9. 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</a></li><li><a href="#_10-javascript-中-callee-和-caller-的作用？">10. Javascript 中 callee 和 caller 的作用？</a></li><li><a href="#_11-javascript-的作用域和作用域链">11. JavaScript 的作用域和作用域链</a></li><li><a href="#_12-javascript-的继承">12. JavaScript 的继承</a></li><li><a href="#_13-跨域的几种方式">13. 跨域的几种方式</a></li><li><a href="#_14-事件委托机制">14. 事件委托机制</a></li><li><a href="#_15-谈谈对前端模块化的理解">15. 谈谈对前端模块化的理解</a></li><li><a href="#_16-bind-函数的兼容性">16. bind 函数的兼容性</a></li><li><a href="#_17-解释下事件代理">17. 解释下事件代理</a></li><li><a href="#_18-undefined-和-null-的区别-还有-undeclared">18. undefined 和 null 的区别, 还有 undeclared:</a></li><li><a href="#_19-事件冒泡机制">19. 事件冒泡机制:</a></li><li><a href="#_20-什么是-use-strict-其好处坏处分别是什么">20. 什么是 use strict? 其好处坏处分别是什么?</a></li><li><a href="#_21-浏览器端的-js-包括哪几个部分">21. 浏览器端的 js 包括哪几个部分?</a></li><li><a href="#_22-基本类型与引用类型有什么区别">22. 基本类型与引用类型有什么区别?</a></li><li><a href="#_23-js-有几种函数调用方式">23. js 有几种函数调用方式?</a></li><li><a href="#_24-描述事件模型-ie-的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？">24. 描述事件模型?IE 的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？</a></li><li><a href="#_25-如何判断属性来自自身对象还是原型链">25. 如何判断属性来自自身对象还是原型链?</a></li><li><a href="#_26-图片预加载的实现">26. 图片预加载的实现</a></li><li><a href="#_27-如果在同一个元素上绑定了两个-click-事件-一个在捕获阶段执行-一个在冒泡阶段执行-那么当触发-click-条件时-会执行几个事件-执行顺序是什么">27. 如果在同一个元素上绑定了两个 click 事件, 一个在捕获阶段执行, 一个在冒泡阶段执行. 那么当触发 click 条件时, 会执行几个事件? 执行顺序是什么?</a></li><li><a href="#_28-js-中怎么实现块级作用域">28. js 中怎么实现块级作用域?</a></li><li><a href="#_29-构造函数里定义-function-和使用-prototype-func-的区别？">29. 构造函数里定义 function 和使用 prototype.func 的区别？</a></li><li><a href="#_30-js-实现对象的深克隆">30. js 实现对象的深克隆</a></li><li><a href="#_31-web-worker-和-websocket">31. Web Worker 和 webSocket</a></li><li><a href="#_32-栈和队列的区别">32. 栈和队列的区别?</a></li><li><a href="#_33-js-继承方式及其优缺点">33. js 继承方式及其优缺点</a></li><li><a href="#_34-用过哪些设计模式？">34. 用过哪些设计模式？</a></li><li><a href="#_35-javascript-对象的几种创建方式">35. javascript 对象的几种创建方式</a></li><li><a href="#_36-异步加载和延迟加载">36. 异步加载和延迟加载</a></li><li><a href="#_37-请解释一下-javascript-的同源策略。">37. 请解释一下 JavaScript 的同源策略。</a></li><li><a href="#_38-documen-write-和-innerhtml-的区别">38. documen.write 和 innerHTML 的区别</a></li><li><a href="#_38-如何阻止事件的冒泡">38. 如何阻止事件的冒泡?</a></li><li><a href="#_40-如何规避-javascript-多人开发函数重名问题？">40. 如何规避 javascript 多人开发函数重名问题？</a></li><li><a href="#_41-请给出异步加载-js-方案，不少于两种">41. 请给出异步加载 js 方案，不少于两种</a></li><li><a href="#_42-javascript-的本地对象，内置对象和宿主对象">42. javascript 的本地对象，内置对象和宿主对象</a></li><li><a href="#_43-js-中那两个可以将数组参数打散将值一个一个的传入">43. js 中那两个可以将数组参数打散将值一个一个的传入</a></li><li><a href="#_44-创建-3-种">44. 创建: 3 种:</a></li><li><a href="#_45-重载-overload">45. *重载(overload):</a></li><li><a href="#_46-原型链-prototype-chain">46. ***原型链(prototype chain):</a></li><li><a href="#_48-谈谈对面向对象的理解">48. 谈谈对面向对象的理解</a></li><li><a href="#_50-apply-和-call-的区别">50. apply()和 call()的区别</a></li><li><a href="#_53-解析-jsonp-的原理，以及-js-的同源策略">53. 解析 jsonp 的原理，以及 js 的同源策略</a></li></ul></li></ul></div><p></p> <h3 id="_1-this-对象的理解"><a href="#_1-this-对象的理解" aria-hidden="true" class="header-anchor">#</a> 1. this 对象的理解</h3> <p>this 总是指向函数的直接调用者（而非间接调用者）；
如果有 new 关键字，this 指向 new 出来的那个对象；
在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window；</p> <h3 id="_2-解释下-js-中-this-是怎么工作的"><a href="#_2-解释下-js-中-this-是怎么工作的" aria-hidden="true" class="header-anchor">#</a> 2. 解释下 js 中 this 是怎么工作的?</h3> <p>this 在 JavaScript 中主要由以下五种使用场景。
作为函数调用，this 绑定全局对象，浏览器环境全局对象为 window 。
内部函数内部函数的 this 也绑定全局对象，应该绑定到其外层函数对应的对象上，这是 JavaScript 的缺陷，用 that 替换。
作为构造函数使用，this 绑定到新创建的对象。
作为对象方法使用，this 绑定到该对象。
使用 apply 或 call 调用 this 将会被显式设置为函数调用的第一个参数。</p> <h3 id="_3-eval-是做什么的？"><a href="#_3-eval-是做什么的？" aria-hidden="true" class="header-anchor">#</a> 3. eval 是做什么的？</h3> <p>它的功能是把对应的字符串解析成 JS 代码并运行；
应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。
由 JSON 字符串转换为 JSON 对象的时候可以用 eval，var obj =eval('('+ str +')');</p> <h3 id="_4-new-操作符具体干了什么呢"><a href="#_4-new-操作符具体干了什么呢" aria-hidden="true" class="header-anchor">#</a> 4. new 操作符具体干了什么呢?</h3> <p>（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
（2）属性和方法被加入到 this 引用的对象中。
（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p> <h3 id="_5-你有哪些性能优化的方法？"><a href="#_5-你有哪些性能优化的方法？" aria-hidden="true" class="header-anchor">#</a> 5. 你有哪些性能优化的方法？</h3> <p>（1） 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适； 网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
（2） 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
（3） 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
（4） 当需要设置的样式很多时设置 className 而不是直接操作 style。
（5） 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
（6） 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属 性)。
（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
（8） 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后 才会显示出来，显示比 div+css 布局慢。</p> <h3 id="_6-哪些常见操作会造成内存泄漏？"><a href="#_6-哪些常见操作会造成内存泄漏？" aria-hidden="true" class="header-anchor">#</a> 6. 哪些常见操作会造成内存泄漏？</h3> <p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p> <h3 id="_7-线程与进程的区别"><a href="#_7-线程与进程的区别" aria-hidden="true" class="header-anchor">#</a> 7. 线程与进程的区别</h3> <p>一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线 程的重要区别。</p> <h3 id="_8-什么是闭包？"><a href="#_8-什么是闭包？" aria-hidden="true" class="header-anchor">#</a> 8. 什么是闭包？</h3> <p>闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。
闭包的特点：
（1）作为一个函数变量的一个引用，当函数返回时，其处于激活状态。
（2） 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
简单的说，Javascript 允许使用内部函数---即函数定义和函数表达式位于另一个 函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有 局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的 外部函数之外被调用时，就会形成闭包。
闭包简单的说就是一个函数能访问外部函数的变量，这就是闭包，比如说：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">var</span> tem<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
      <span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">++</span>tem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

a函数中的b函数就是闭包了，b函数可以使用a函数的局部变量，参数，最典型的闭包应该是下面这样，将定义在函数中的函数作为返回值

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">var</span> tem<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
      <span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">++</span>tem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
闭包的另一种作用是隔离作用域，请看下面这段代码

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面这段代码的执行结果是<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span>而不是<span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>，因为等<span class="token keyword">for</span>循环出来后，执行setTimeout中的函数时，i的值已经变成了<span class="token number">2</span>，这就是没有隔离作用域所造成的，请看下面代码

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样就会输出 0,1，我们的立即执行函数创建了一个作用域，隔离了外界的作用域，闭包的缺点是，因为内部闭包函数可以访问外部函数的变量，所以外部函数的变量不能被释放，如果闭包嵌套过多，会导致内存占用大，要合理使用闭包。
写一个简单的闭包，并说说闭包的优缺点。
好处:
(1)不增加额外的全局变量。
(2)执行过程中所有变量都是在匿名函数内部。
坏处:
(1)由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能 滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是， 在退出函数之前，将不使用的局部变量全部删除。
(2)闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当 作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量 当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部 变量的值。</p> <h3 id="_9-在-javascript-中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#_9-在-javascript-中什么是伪数组？如何将伪数组转化为标准数组？" aria-hidden="true" class="header-anchor">#</a> 9. 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h3> <p>伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为， 但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有 像调用 getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray) 将数组转化为真正的 Array 对象。
function log(){
var args = Array.prototype.slice.call(arguments); //为了使用 unshift 数组方法，将 argument 转化为真正的数组
args.unshift('(app)');
console.log.apply(console, args);};</p> <h3 id="_10-javascript-中-callee-和-caller-的作用？"><a href="#_10-javascript-中-callee-和-caller-的作用？" aria-hidden="true" class="header-anchor">#</a> 10. Javascript 中 callee 和 caller 的作用？</h3> <p>caller 是返回一个对函数的引用，该函数调用了当前函数；
callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正 文。</p> <h3 id="_11-javascript-的作用域和作用域链"><a href="#_11-javascript-的作用域和作用域链" aria-hidden="true" class="header-anchor">#</a> 11. JavaScript 的作用域和作用域链</h3> <p>JavaScript 的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个对象的原型对象中去查找，还是没有的话，就到该作用域所在的作用域中找，直到到 window 所在的作用域，每个函数在声明的时候就默认有一个外部作用域的存在了，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">var</span> tem<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>
      funciton <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">var</span> temo<span class="token operator">=</span><span class="token number">34</span><span class="token punctuation">;</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token string">&quot; &quot;</span><span class="token operator">+</span>tem<span class="token operator">+</span><span class="token string">&quot; &quot;</span><span class="token operator">+</span>temo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>bar 找 t 变量的过程就是，先到自己的内部作用域中找，发现没有找到，然后到 bar 所在的最近的外部变量中找，也就是 foo 的内部作用域，还是没有找到，再到 window 的作用域中找，结果找到了</p> <h3 id="_12-javascript-的继承"><a href="#_12-javascript-的继承" aria-hidden="true" class="header-anchor">#</a> 12. JavaScript 的继承</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span> <span class="token punctuation">}</span>

原型继承

<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token string">&quot;mbj&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//被B的实例共享</span>
<span class="token keyword">var</span> foo<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token comment">//18,age是本身携带的属性</span>
foo<span class="token punctuation">.</span>name<span class="token punctuation">;</span>   <span class="token comment">//mbj，等价于foo.__proto__.name</span>
foo<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//mbj,等价于foo.__proto__.proto__.sayName()</span>
foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//&quot;[object Object]&quot;,等价于foo.__proto__.__proto__.__proto__.toString();</span>
这样<span class="token constant">B</span>通过原型继承了<span class="token constant">A</span>，在<span class="token keyword">new</span> <span class="token class-name">B</span>的时候，foo中有个隐藏的属性__proto__指向构造函数的prototype对象，在这里是<span class="token constant">A</span>对象实例，<span class="token constant">A</span>对象里面也有一个隐藏的属性__proto__<span class="token punctuation">,</span>指向<span class="token constant">A</span>构造函数的prototype对象，这个对象里面又有一个__proto__指向Object的prototype
这种方式的缺第一个缺点是所有子类共享父类实例，如果某一个子类修改了父类，其他的子类在继承的时候，会造成意想不到的后果。第二个缺点是在构造子类实例的时候，不能给父类传递参数。
构造函数继承
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> foo<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">&quot;wmy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>name<span class="token punctuation">;</span>     <span class="token comment">//wmy</span>
foo<span class="token punctuation">.</span>age<span class="token punctuation">;</span>      <span class="token comment">//18</span>
foo<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//undefined</span>
采用这种方式继承是把<span class="token constant">A</span>中的属性加到<span class="token keyword">this</span>上面，这样name相当于就是<span class="token constant">B</span>的属性，sayName不在<span class="token constant">A</span>的构造函数中，所以访问不到sayName。这种方法的缺点是父类的prototype中的函数不能复用。
原型继承<span class="token operator">+</span>构造函数继承

<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token string">&quot;mbj&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">&quot;wmy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>name<span class="token punctuation">;</span>     <span class="token comment">//wmy</span>
foo<span class="token punctuation">.</span>age<span class="token punctuation">;</span>      <span class="token comment">//18</span>
foo<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//wmy</span>
</code></pre></div><p>这样就可以成功访问 sayName 函数了，结合了上述两种方式的优点，但是这种方式也有缺点，那就是占用的空间更大了。</p> <h3 id="_13-跨域的几种方式"><a href="#_13-跨域的几种方式" aria-hidden="true" class="header-anchor">#</a> 13. 跨域的几种方式</h3> <p>jsonp（利用 script 标签的跨域能力）跨域、websocket（html5 的新特性，是一种新协议）跨域、设置代理服务器（由服务器替我们向不同源的服务器请求数据）、CORS（跨源资源共享，cross origin resource sharing）、iframe 跨域、postMessage(包含 iframe 的页面向 iframe 传递消息)</p> <h3 id="_14-事件委托机制"><a href="#_14-事件委托机制" aria-hidden="true" class="header-anchor">#</a> 14. 事件委托机制</h3> <p>事件委托指的是，不再事件的发生地设立监听函数，而是在事件发生地的父元素或者祖先元素设置监听器函数，这样可以大大提高性能，因为可以减少绑定事件的元素，比如：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>要给 li 元素绑定 click 事件，使用事件委托机制的话，就只需要给 ul 绑定 click 事件就行了，这样就不需要给每个 li'绑定 click 事件，减小内存占用，提高效率，有兴趣的童鞋可以去看看 jQuery 的 live，bind，on，delegate 函数的区别，这几个函数就采用了事件委托机制。</p> <h3 id="_15-谈谈对前端模块化的理解"><a href="#_15-谈谈对前端模块化的理解" aria-hidden="true" class="header-anchor">#</a> 15. 谈谈对前端模块化的理解</h3> <p>前端模块话就是把复杂的文件分成一个个独立的模块，比如 js 文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了 CommonJS、AMD、CMD 规范，最后出现了 webpack，webpack 就是前端模块话的一种解决方案，基本上大公司都会使用 webpack，想要详细的学习 webpack 的话请看 webpack 简明使用教程</p> <h3 id="_16-bind-函数的兼容性"><a href="#_16-bind-函数的兼容性" aria-hidden="true" class="header-anchor">#</a> 16. bind 函数的兼容性</h3> <p>用法:
bind()函数会创建一个新函数, 为绑定函数。当调用这个绑定函数时,绑定函数会以创建它时传入 bind 方法的第一个参数作为 this,传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.
一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p> <h3 id="_17-解释下事件代理"><a href="#_17-解释下事件代理" aria-hidden="true" class="header-anchor">#</a> 17. 解释下事件代理</h3> <p>事件委托利用了事件冒泡, 只指定一个事件处理程序, 就可以管理某一类型的所有事件.
例: html 部分: 要点击 li 弹出其 id</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-3<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-4<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-5<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>li-6<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Li 7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>javascript 代码效果预览</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//js部分</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> e <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
  <span class="token keyword">var</span> target <span class="token operator">=</span> e<span class="token punctuation">.</span>target <span class="token operator">||</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span>toUpperCase <span class="token operator">==</span> <span class="token string">&quot;LI&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;List item&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> target<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">&quot;was clicked!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_18-undefined-和-null-的区别-还有-undeclared"><a href="#_18-undefined-和-null-的区别-还有-undeclared" aria-hidden="true" class="header-anchor">#</a> 18. undefined 和 null 的区别, 还有 undeclared:</h3> <p>null 表示没有对象, 即此处不该有此值. 典型用法:
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
（3） null 可以作为空指针. 只要意在保存对象的值还没有真正保存对象,就应该明确地让该对象保存 null 值.
undefined 表示缺少值, 即此处应该有值, 但还未定义.
（1）变量被声明了，但没有赋值时，就等于 undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
（3）对象没有赋值的属性，该属性的值为 undefined。
（4）函数没有返回值时，默认返回 undefined。
undeclared 即为被污染的命名, 访问没有被声明的变量, 则会抛出异常, 终止执行. 即 undeclared 是一种语法错误</p> <h3 id="_19-事件冒泡机制"><a href="#_19-事件冒泡机制" aria-hidden="true" class="header-anchor">#</a> 19. 事件冒泡机制:</h3> <p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。如果想阻止事件起泡，可以使用 e.stopPropagation()（Firefox）或者 e.cancelBubble=true（IE）来组织事件的冒泡传播。</p> <h3 id="_20-什么是-use-strict-其好处坏处分别是什么"><a href="#_20-什么是-use-strict-其好处坏处分别是什么" aria-hidden="true" class="header-anchor">#</a> 20. 什么是 use strict? 其好处坏处分别是什么?</h3> <p>在所有的函数 (或者所有最外层函数) 的开始处加入 &quot;use strict&quot;; 指令启动严格模式。</p> <p>&quot;严格模式&quot;有两种调用方法</p> <p>1）将&quot;use strict&quot;放在脚本文件的第一行，则整个脚本都将以&quot;严格模式&quot;运行。如果这行语句不在第一行，则无效，整个脚本以&quot;正常模式&quot;运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p> <p>2）将整个脚本文件放在一个立即执行的匿名函数之中。
好处</p> <ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li> <li>消除代码运行的一些不安全之处，保证代码运行的安全；</li> <li>提高编译器效率，增加运行速度；</li> <li>为未来新版本的 Javascript 做好铺垫。
坏处　
同样的代码，在&quot;严格模式&quot;中，可能会有不一样的运行结果；一些在&quot;正常模式&quot;下可以运行的语句，在&quot;严格模式&quot;下将不能运行</li></ul> <h3 id="_21-浏览器端的-js-包括哪几个部分"><a href="#_21-浏览器端的-js-包括哪几个部分" aria-hidden="true" class="header-anchor">#</a> 21. 浏览器端的 js 包括哪几个部分?</h3> <p>核心( ECMAScript) , 文档对象模型(DOM), 浏览器对象模型(BOM)</p> <h3 id="_22-基本类型与引用类型有什么区别"><a href="#_22-基本类型与引用类型有什么区别" aria-hidden="true" class="header-anchor">#</a> 22. 基本类型与引用类型有什么区别?</h3> <p>基本类型如上题所示. 引用类型则有: Object, Array, Date, RegExp, Function</p> <p>存储</p> <p>基本类型值在内存中占据固定大小的空间,因此被保存在栈内存中</p> <p>引用类型的值是对象, 保存在堆内存中. 包含引用类型的变量实际上包含的并不是对象本身, 而是一个指向改对象的指针</p> <p>复制</p> <p>从一个变量向另一个变量复制基本类型的值, 会创建这个值的一个副本</p> <p>从一个变量向另一个变量复制引用类型的值, 复制的其实是指针,　因此两个变量最终都指向同一个对象</p> <p>检测类型</p> <p>确定一个值是哪种基本类型可以用 typeof 操作符,</p> <p>而确定一个值是哪种引用类型可以使用 instanceof 操作符</p> <h3 id="_23-js-有几种函数调用方式"><a href="#_23-js-有几种函数调用方式" aria-hidden="true" class="header-anchor">#</a> 23. js 有几种函数调用方式?</h3> <p>方法调用模型 var obj = { func : function(){};} obj.func()</p> <p>函数调用模式　　 var func = function(){} func();</p> <p>构造器调用模式</p> <p>apply/ call 调用模式</p> <h3 id="_24-描述事件模型-ie-的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？"><a href="#_24-描述事件模型-ie-的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？" aria-hidden="true" class="header-anchor">#</a> 24. 描述事件模型?IE 的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？</h3> <p>捕获-&gt;处于目标-&gt;冒泡，IE 应该是只有冒泡没有捕获。</p> <p>事件代理就是在父元素上绑定事件来处理，通过 event 对象的 target 来定位。</p> <h3 id="_25-如何判断属性来自自身对象还是原型链"><a href="#_25-如何判断属性来自自身对象还是原型链" aria-hidden="true" class="header-anchor">#</a> 25. 如何判断属性来自自身对象还是原型链?</h3> <p>hasOwnPrototype</p> <h3 id="_26-图片预加载的实现"><a href="#_26-图片预加载的实现" aria-hidden="true" class="header-anchor">#</a> 26. 图片预加载的实现</h3> <p>使用 jQuery 图片预加载插件 Lazy Load</p> <ol><li>加载 jQuery, 与 jquery.lazyload.js</li> <li>设置图片的占位符为 data-original, 给图片一个特别的标签,比如 class=&quot;.lazy&quot;</li> <li>然后延迟加载: $('img.lazy').lazyload();这个函数可以选择一些参数:
3.1. 图片预先加载距离：threshold，通过设置这个值，在图片未出现在可视区域的顶部距离这个值时加载。</li></ol> <p>3.2.事件绑定加载的方式：event</p> <p>3.3.图片限定在某个容器内：container</p> <p>使用 js 实现图片加载: 就是 new 一个图片对象, 绑定 onload 函数, 赋值 url</p> <p>用 CSS 实现图片的预加载</p> <p>写一个 CSS 样式设置一批背景图片，然后将其隐藏</p> <p>改进: 使用 js 来推迟预加载时间, 防止与页面其他内容一起加载</p> <p>用 Ajax 实现预加载</p> <p>其实就是通过 ajax 请求请求图片地址. 还可以用这种方式加载 css,js 文件等</p> <h3 id="_27-如果在同一个元素上绑定了两个-click-事件-一个在捕获阶段执行-一个在冒泡阶段执行-那么当触发-click-条件时-会执行几个事件-执行顺序是什么"><a href="#_27-如果在同一个元素上绑定了两个-click-事件-一个在捕获阶段执行-一个在冒泡阶段执行-那么当触发-click-条件时-会执行几个事件-执行顺序是什么" aria-hidden="true" class="header-anchor">#</a> 27. 如果在同一个元素上绑定了两个 click 事件, 一个在捕获阶段执行, 一个在冒泡阶段执行. 那么当触发 click 条件时, 会执行几个事件? 执行顺序是什么?</h3> <p>绑定在目标元素上的事件是按照绑定的顺序执行的!!!!</p> <p>即: 绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照 W3C 的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。</p> <h3 id="_28-js-中怎么实现块级作用域"><a href="#_28-js-中怎么实现块级作用域" aria-hidden="true" class="header-anchor">#</a> 28. js 中怎么实现块级作用域?</h3> <p>使用匿名函数, (立即执行函数)
(function(){...})()</p> <h3 id="_29-构造函数里定义-function-和使用-prototype-func-的区别？"><a href="#_29-构造函数里定义-function-和使用-prototype-func-的区别？" aria-hidden="true" class="header-anchor">#</a> 29. 构造函数里定义 function 和使用 prototype.func 的区别？</h3> <ol><li>直接调用 function，每一个类的实例都会拷贝这个函数，弊端就是浪费内存（如上）。prototype 方式定义的方式，函数不会拷贝到每一个实例中，所有的实例共享 prototype 中的定义，节省了内存。</li> <li>但是如果 prototype 的属性是对象的话，所有实例也会共享一个对象（这里问的是函数应该不会出现这个情况），如果其中一个实例改变了对象的值，则所有实例的值都会被改变。同理的话，如果使用 prototype 调用的函数，一旦改变，所有实例的方法都会改变。——不可以对实例使用 prototype 属性，只能对类和函数用。</li></ol> <h3 id="_30-js-实现对象的深克隆"><a href="#_30-js-实现对象的深克隆" aria-hidden="true" class="header-anchor">#</a> 30. js 实现对象的深克隆</h3> <p>因为 js 中数据类型分为基本数据类型(number, string, boolean, null, undefined)和引用类型值(对象, 数组, 函数). 这两类对象在复制克隆的时候是有很大区别的. 原始类型存储的是对象的实际数据, 而对象类型存储的是对象的引用地址(对象的实际内容单独存放, 为了减少数据开销通常放在内存中). 此外, 对象的原型也是引用对象, 它把原型的属性和方法放在内存中, 通过原型链的方式来指向这个内存地址.</p> <p>于是克隆也会分为两类:</p> <p>浅度克隆:</p> <p>原始类型为值传递, 对象类型仍为引用传递</p> <p>深度克隆:</p> <p>所有元素或属性均完全复制, 与原对象完全脱离, 也就是说所有对于新对象的修改都不会反映到原对象中
深度克隆实现:</p> <p>javascript 代码效果预览</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> attr <span class="token operator">=</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_31-web-worker-和-websocket"><a href="#_31-web-worker-和-websocket" aria-hidden="true" class="header-anchor">#</a> 31. Web Worker 和 webSocket</h3> <p>worker 主线程: 1.通过 worker = new Worker( url ) 加载一个 JS 文件来创建一个 worker，同时 返回一个 worker 实例。 2.通过 worker.postMessage( data ) 方法来向 worker 发送数据。 3.绑定 worker.onmessage 方法来接收 worker 发送过来的数据。 4.可以使用 worker.terminate() 来终止一个 worker 的执行。
WebSocket 是 Web 应用程序的传输协议，它提供了双向的，按序到达的数据流。他 是一个 Html5 协议，WebSocket 的连接是持久的，他通过在客户端和服务器之间保 持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间 间隔去轮询。</p> <h3 id="_32-栈和队列的区别"><a href="#_32-栈和队列的区别" aria-hidden="true" class="header-anchor">#</a> 32. 栈和队列的区别?</h3> <p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</p> <p>队列先进先出，栈先进后出。</p> <p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</p> <div class="warning custom-block"><p>栈和堆的区别？</p></div> <p>栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。</p> <h3 id="_33-js-继承方式及其优缺点"><a href="#_33-js-继承方式及其优缺点" aria-hidden="true" class="header-anchor">#</a> 33. js 继承方式及其优缺点</h3> <p>原型链继承的缺点</p> <p>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p> <p>借用构造函数（类式继承）</p> <p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p> <p>组合式继承</p> <p>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p> <h3 id="_34-用过哪些设计模式？"><a href="#_34-用过哪些设计模式？" aria-hidden="true" class="header-anchor">#</a> 34. 用过哪些设计模式？</h3> <p>工厂模式：
主要好处就是可以消除对象间的耦合，通过使用工程方法而不是 new 关键字。将所有实例化的代码集中在一个位置防止代码重复。
工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> profession</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//集中实例化的函数var obj = new Object();</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>profession <span class="token operator">=</span> profession<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot; at &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">&quot; engaged in &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>profession<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> test1 <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token string">&quot;trigkit4&quot;</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">&quot;programmer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例</span>
</code></pre></div><p>构造函数模式
使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 1.构造函数方法没有显示的创建对象 (new Object()); 2.直接将属性和方法赋值给 this 对象; 3.没有 renturn 语句。</p> <h3 id="_35-javascript-对象的几种创建方式"><a href="#_35-javascript-对象的几种创建方式" aria-hidden="true" class="header-anchor">#</a> 35. javascript 对象的几种创建方式</h3> <ol><li>工厂模式</li> <li>构造函数模式</li> <li>原型模式</li> <li>混合构造函数和原型模式</li> <li>动态原型模式</li> <li>寄生构造函数模式</li> <li>稳妥构造函数模式
javascript 继承的 6 种方法</li> <li>原型链继承</li> <li>借用构造函数继承</li> <li>组合继承(原型+借用构造)</li> <li>原型式继承</li> <li>寄生式继承</li> <li>寄生组合式继承</li></ol> <h3 id="_36-异步加载和延迟加载"><a href="#_36-异步加载和延迟加载" aria-hidden="true" class="header-anchor">#</a> 36. 异步加载和延迟加载</h3> <ol><li>异步加载的方案： 动态插入 script 标签</li> <li>通过 ajax 去获取 js 代码，然后通过 eval 执行</li> <li>script 标签上添加 defer 或者 async 属性</li> <li>创建并插入 iframe，让它异步执行 js</li> <li>延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些 情况才需要的。</li></ol> <h3 id="_37-请解释一下-javascript-的同源策略。"><a href="#_37-请解释一下-javascript-的同源策略。" aria-hidden="true" class="header-anchor">#</a> 37. 请解释一下 JavaScript 的同源策略。</h3> <p>概念:同源策略是客户端脚本（尤其是 Javascript）的重要的安全度量标准它最早 出自 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同装载。</p> <p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p> <p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p> <p>为什么要有同源限制？</p> <p>我们举例说明：比如一个黑客程序，他利用 Iframe 把真正的银行登录页面嵌到他 的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表单中 input 中的内容，这样用户名，密码就轻松到手了。</p> <p>缺点：
现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这 些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有 指示严格模式，反而在压缩后浪费了字节。</p> <h3 id="_38-documen-write-和-innerhtml-的区别"><a href="#_38-documen-write-和-innerhtml-的区别" aria-hidden="true" class="header-anchor">#</a> 38. documen.write 和 innerHTML 的区别</h3> <p>document.write 只能重绘整个页面</p> <p>innerHTML 可以重绘页面的一部分</p> <h3 id="_38-如何阻止事件的冒泡"><a href="#_38-如何阻止事件的冒泡" aria-hidden="true" class="header-anchor">#</a> 38. 如何阻止事件的冒泡?</h3> <p>答案：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//阻止冒泡的方法</span>
<span class="token keyword">function</span> <span class="token function">stopPP</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> evt <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
  <span class="token comment">//IE用cancelBubble=true来阻止而FF下需要用stopPropagation方法</span>
  evt<span class="token punctuation">.</span>stopPropagation <span class="token operator">?</span> evt<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>evt<span class="token punctuation">.</span>cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_40-如何规避-javascript-多人开发函数重名问题？"><a href="#_40-如何规避-javascript-多人开发函数重名问题？" aria-hidden="true" class="header-anchor">#</a> 40. 如何规避 javascript 多人开发函数重名问题？</h3> <p>答案：
(1) 可以开发前规定命名规范，根据不同开发人员开发的功能在函数前加前缀
(2) 将每个开发人员的函数封装到类中，调用的时候就调用类的函数，即使函数重 名只要类名不重复就行</p> <h3 id="_41-请给出异步加载-js-方案，不少于两种"><a href="#_41-请给出异步加载-js-方案，不少于两种" aria-hidden="true" class="header-anchor">#</a> 41. 请给出异步加载 js 方案，不少于两种</h3> <p>答案：默认情况 javascript 是同步加载的，也就是 javascript 的加载时阻塞的， 后面的元素要等待 javascript 加载完毕后才能进行再加载，对于一些意义不是很 大的 javascript，如果放在页头会导致加载很慢的话，是会严重影响用户体验的。
异步加载方式：
defer，只支持 IE
async：
创建 script，插入到 DOM 中，加载完毕后 callBack，见代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/javascript&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>script<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//IE</span>
    script<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>script<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token string">&quot;loaded&quot;</span> <span class="token operator">||</span> script<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token string">&quot;complete&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        script<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//Others: Firefox, Safari, Chrome, and Opera</span>
    script<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_42-javascript-的本地对象，内置对象和宿主对象"><a href="#_42-javascript-的本地对象，内置对象和宿主对象" aria-hidden="true" class="header-anchor">#</a> 42. javascript 的本地对象，内置对象和宿主对象</h3> <p>本地对象为 array obj regexp 等可以 new 实例化
内置对象为 gload Math 等不可以实例化的
宿主为浏览器自带的 document,window 等</p> <h3 id="_43-js-中那两个可以将数组参数打散将值一个一个的传入"><a href="#_43-js-中那两个可以将数组参数打散将值一个一个的传入" aria-hidden="true" class="header-anchor">#</a> 43. js 中那两个可以将数组参数打散将值一个一个的传入</h3> <p>数组中的 concat 不修改原数组，返回新数组
apply()方法</p> <h3 id="_44-创建-3-种"><a href="#_44-创建-3-种" aria-hidden="true" class="header-anchor">#</a> 44. 创建: 3 种:</h3> <ol><li>声明:</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token parameter">参数列表</span><span class="token punctuation">)</span><span class="token punctuation">{</span>函数体<span class="token punctuation">;</span> <span class="token keyword">return</span> 返回值<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><pre><code>      何时: 只要一段代码被反复使用，都要先定义在一个专门的函数中，再反复	调用函数即可——复用
         何时使用参数: 只要函数步骤中必须某些数据才能正常执行时，就要定	义参数。
         何时使用返回值: 如果函数的调用者需要函数的执行结果时，函数就必	须返回值。
     可被声明提前:
</code></pre> <ol start="2"><li>函数直接量:</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>       <span class="token keyword">var</span>  <span class="token function-variable function">函数名</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">参数列表</span><span class="token punctuation">)</span><span class="token punctuation">{</span>函数体<span class="token punctuation">;</span> <span class="token keyword">return</span> 返回值<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><pre><code>     不会被声明提前。
</code></pre> <p>声明提前(hoist): 在开始执行程序前，将所有 var 声明的变量和 function 声明的函数提前到<em>当前作用域</em>的顶部，集中创建。</p> <p>赋值留在原地!</p> <p>何时: 只要不希望被声明提前时。
揭示了: 函数名仅是一个普通的变量
函数定义其实是一个对象
函数名中仅保存了函数对象的地址——引用
3. 用new:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fun<span class="token operator">=</span>
<span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;参数 1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;参数 2&quot;</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">,</span><span class="token string">&quot;函数体; return 返回值&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_45-重载-overload"><a href="#_45-重载-overload" aria-hidden="true" class="header-anchor">#</a> 45. *重载(overload):</h3> <ul><li><p>什么是: 相同函数名，不同参数列表的多个函数，在调用时，可根据传入参数的不 同，自动选择对应的函数调用！</p></li> <li><p>为什么: 减轻调用者的负担，一个函数名，可执行多种操作</p></li> <li><p>何时: 一项任务，根据不同的参数，执行不同的操作流程时</p></li> <li><p>如何: js 语法不支持重载效果</p></li> <li><p>变通: 所有函数对象内，都自动内建了一个 arguments 对象</p></li> <li><p>arguments 对象:
专门保存传入函数的所有参数值的类数组对象
类数组对象: (object like array)</p></li> <li><p>vs 数组: 相同: 下标, length, for 遍历
不同: 类数组对象是 Object,不是 Array,无法使用 ArrayAPI
数组是 Array 类型，可以使用数组类型所有的 API</p></li></ul> <h3 id="_46-原型链-prototype-chain"><a href="#_46-原型链-prototype-chain" aria-hidden="true" class="header-anchor">#</a> 46. ***原型链(prototype chain):</h3> <p>什么是原型链: 多级父对象连续继承，形成的链式结构</p> <ul><li>保存了: 对象的属性和方法</li> <li>控制了: 对象的成员的使用顺序</li> <li>优先使用自有成员</li> <li>自己没有才延原型链向父级查找，只要找到就不再向上</li> <li>如果整个原型链上都没有，才返回 undefind</li> <li>vs 作用域链(scope chain)
作用域链(scope chain): 由多个作用域对象连续引用形成的链式结构。</li> <li>保存了: 全局/局部的变量</li> <li>控制了: 变量的使用顺序</li> <li>优先在当前函数调用的函数作用域对象(AO)中查找</li> <li>如果函数作用域对象(AO)中没有,才延作用域链向全局方向查找。只要找到，就 不再继续如果整个作用域链上都没有，才报错</li></ul> <h3 id="_48-谈谈对面向对象的理解"><a href="#_48-谈谈对面向对象的理解" aria-hidden="true" class="header-anchor">#</a> 48. 谈谈对面向对象的理解</h3> <p>什么是: 程序中都是先用对象来定义数据和功能，再按照逻辑的需要，访问对象中的数据和功能。</p> <p>什么是对象: 内存中同时存储多个数据和功能的存储空间</p> <p>描述现实中一个具体事物的属性和功能的程序结构</p> <p>事物的属性，会成为对象中的属性</p> <p>事物的功能，会成为对象中的方法</p> <p>面向对象三大特点: 封装，继承，多态</p> <p>封装: 将一个具体事物的属性和功能集中定义在一个对象中</p> <ol><li>使用对象直接量:</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>              <span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
                  属性名<span class="token punctuation">:</span> 属性值<span class="token punctuation">,</span>
                         <span class="token operator">...</span> <span class="token punctuation">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
                  <span class="token function-variable function">方法名</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span> <span class="token keyword">this</span><span class="token punctuation">.</span>属性名 <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                         <span class="token operator">...</span> <span class="token punctuation">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
              <span class="token punctuation">}</span>
</code></pre></div><p>强调: 对象自己的方法，要访问自己的属性，必须用 this.属性名.</p> <p>this-&gt;正在调用函数的当前对象自己</p> <ol start="2"><li>使用 new: 2 步:</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>          <span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个空对象</span>
          <span class="token comment">//向空对象中添加属性和方法</span>
          obj<span class="token punctuation">.</span>属性名<span class="token operator">=</span>属性值<span class="token punctuation">;</span>
          obj<span class="token punctuation">.</span><span class="token function-variable function">方法名</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>属性名<span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>对象的本质: js 中一切对象的底层都是关联数组</p> <p>每个属性/方法都是关联数组中的元素</p> <p>属性名/方法名是 key，属性值/函数对象是 value</p> <p>问题: 一次只能创建一个对象</p> <ol start="3"><li>解决: 用构造函数:</li></ol> <p>什么是构造函数: 专门描述一类对象统一结构的函数</p> <p>何时: 今后只要反复创建多个相同结构的对象时，都要先定义构造函数</p> <p>为什么: 复用对象的结构代码</p> <p>如何: 2 步:</p> <ol><li>定义构造函数</li></ol> <p>function 类型名(属性参数列表){
this.属性名=属性参数值;
...=...;
this.方法名=function(){ ... this.属性名 ... }
}</p> <ol start="2"><li>用 new 调用构造函数，创建并装修新对象
var obj=new 类型名(属性值列表);</li></ol> <p>创建一个指定“类型”的对象</p> <p>用 new 调用指定&quot;类型&quot;的构造函数来创建对象</p> <h4 id="_49-new-4-件事"><a href="#_49-new-4-件事" aria-hidden="true" class="header-anchor">#</a> 49.new: 4 件事:</h4> <ol><li>创建新的空对象</li> <li>让新对象继承构造函数的原型对象</li> <li>用新对象去调用构造函数</li></ol> <p>向新对象中添加构造函数规定的属性</p> <p>将属性参数的值,保存到新对象的新属性中
向新对象中添加构造函数规定的方法
4. 将新对象的地址保存在变量</p> <p>构造函数的问题: 只能复用代码，不能节约内存</p> <p>继承: 父对象的成员，子对象不用重复创建，也可直接使用</p> <p>为什么: 即节约内存，又代码重用</p> <p>何时: 只要一类子对象，需要相同的属性或功能时，都要将相同的属性和功能仅 在父对象中定义一次即可</p> <p>如何:</p> <p>原型对象: 集中存储同一类型的子对象所需的所有共有属性和方法的父对象</p> <h3 id="_50-apply-和-call-的区别"><a href="#_50-apply-和-call-的区别" aria-hidden="true" class="header-anchor">#</a> 50. apply()和 call()的区别</h3> <h4 id="_51-call-方法"><a href="#_51-call-方法" aria-hidden="true" class="header-anchor">#</a> 51.call 方法:</h4> <ul><li><p>语法：call(thisObj，Object)</p></li> <li><p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。 -说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p></li></ul> <h4 id="_52-apply-方法："><a href="#_52-apply-方法：" aria-hidden="true" class="header-anchor">#</a> 52.apply 方法：</h4> <ul><li>语法：apply(thisObj，[argArray])</li> <li>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</li> <li>说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</li> <li>对于 apply 和 call 两者在作用上是相同的，但两者在参数上有以下区别：
对于第一个参数意义都一样，但对第二个参数：apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）。如 func.call(func1,var1,var2,var3)对应的 apply 写法为：func.apply(func1,[var1,var2,var3])同时使用 apply 的好处是可以直接将当前函数的 arguments 对象作为 apply 的第二个参数传入。</li></ul> <h3 id="_53-解析-jsonp-的原理，以及-js-的同源策略"><a href="#_53-解析-jsonp-的原理，以及-js-的同源策略" aria-hidden="true" class="header-anchor">#</a> 53. 解析 jsonp 的原理，以及 js 的同源策略</h3> <p>利用在页面中创建 script 节点的方法向不同域提交 HTTP 请求的方法称为 JSONP， 这项技术可以解决跨域提交 Ajax 请求的问题
JSONP 跨域 GET 请求是一个常用的解决方案</p> <p>JavaScript 的同源策略。这一策略对于 JavaScript 代码能够访问的页面内容做了 很重要的限制，
即 JavaScript 只能访问与包含它的文档在同一域下的内容 ajax 不能够跨域请 求，xmlhtmmprequerst</p> <p>JSONP 的优点是：</p> <ul><li>它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制；</li> <li>它的兼容性更好，在更加古老的浏览器中都可以运行，</li> <li>不需要 XMLHttpRequest 或 ActiveX 的支持；</li> <li>并且在请求完毕后可以通过调用 callback 的方式回传结果。</li> <li>JSONP 的缺点则是：
它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求；</li></ul> <p>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Interview/JavaScript/" class="prev router-link-active">
          Javascript 题集 1
        </a></span> <span class="next"><a href="/Interview/JavaScript/index2.html">
          javascript 相关程序计算题
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c18ba2b.js" defer></script><script src="/assets/js/2.2d7f6841.js" defer></script><script src="/assets/js/28.4d86e4cc.js" defer></script>
  </body>
</html>
